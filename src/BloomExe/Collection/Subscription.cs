using System;
using System.Linq;
using Amazon.S3.Model;

public class Subscription
{
    public static string kExpiryDateForDeprecatedBrandings = "2025-07-01"; // per Cate. Careful! Make sure to use leading zeros in month and day.
    private SubscriptionTier? TierOverride;
    private string? BrandingKeyOverride;
    private DateTime ExpirationDateOverride = DateTime.MinValue;

    // These options must match the strings used in requiresBloomEnterprise.tsx
    public enum SubscriptionTier
    {
        None,
        Community,
        Enterprise
    }

    public Subscription(string code)
    {
        Code = code;
    }

    // We would really like to say look it's only the code, from that we can get everything else.
    // However there are two cases where that is not enough:
    // 1. Legacy collections will have no code, but only a branding of "Local-Community".
    // 2. We are editing a book that was uploaded to BloomLibrary.org, and we want to use the same branding as when it was uploaded but the code
    // was intentionally blanked so as not to publish it.
    //
    // Though: the existance of specially-named "overrides" feels just barely worth it at the moment. There's a small sense that
    // if everything is overridable, then we should give up on functional approach of computing the other things as needed. I.e., we could stop calling
    // them "overrides" and instead just fill them in the constructor.
    public static Subscription FromCollectionSettingsInfo(
        string code,
        string branding,
        bool editingABlorgBook = false
    )
    {
        if (
            string.IsNullOrWhiteSpace(code)
            && (branding == "Local-Community" || branding == "Local Community")
        )
        {
            // migrating to actual code
            code = "Legacy-LC-005809-2533"; // expires on 1 July 2025
        }

        // When on BloomLibrary.org ou click "Download for Edit", we want to let you use the same tier and
        // branding as when it was uploaded, even if it is expired.
        if (
            editingABlorgBook
            && string.IsNullOrWhiteSpace(code)
            && !string.IsNullOrWhiteSpace(branding)
        )
        {
            var sub = new Subscription(code);
            sub.BrandingKeyOverride = branding;
            sub.ExpirationDateOverride = DateTime.Now.AddDays(1);
            if (branding == "Local-Community" || branding == "Local Community")
            {
                sub.TierOverride = SubscriptionTier.Community;
            }
            else
            {
                sub.TierOverride = SubscriptionTier.Enterprise; // see https://issues.bloomlibrary.org/youtrack/issue/BL-14419
            }
            return sub;
        }

        return new Subscription(code);
    }

    public readonly string Code;
    public string BrandingKey
    {
        get { return GetBranding(false); }
    }

    // From the subscription code extract the project name,
    // everything up to the second-last hyphen.
    private string GetBranding(bool forCheckSum = false)
    {
        if (BrandingKeyOverride != null)
            return BrandingKeyOverride;
        if (Code == null)
            return "Default"; // enhance: maybe change everything to just empty string?
        var parts = Code.Split('-').ToList();
        if (parts.Count < 3)
            return "Default";
        parts.RemoveAt(parts.Count - 1);
        parts.RemoveAt(parts.Count - 1);
        var branding = string.Join("-", parts.ToArray());

        // allow for future community codes like HuyaVillage-LC-12335-3233434
        if (!forCheckSum && branding.EndsWith("-LC"))
        {
            return "Local-Community";
        }
        return branding;
    }

    // Parse a string like PNG-RISE-361769-363798 or SIL-LEAD-361769-363644,
    // generated by a private google spreadsheet. The two last elements are numbers;
    // the first is an encoding of an expiry date, the second is a simple hash of
    // the project name (case-insensitive) and the expiry date, used to make it
    // a little less trivial to fake codes. We're not aiming for something that
    // would be difficult for someone willing to take the trouble to read this code.
    public DateTime GetExpirationDate()
    {
        if (ExpirationDateOverride != DateTime.MinValue)
            return ExpirationDateOverride;

        if (Code == null)
            return DateTime.MinValue;

        if (Code == "Local-Community")
            return DateTime.Parse(kExpiryDateForDeprecatedBrandings);
        var parts = Code.Split('-');
        if (parts.Length < 3)
            return DateTime.MinValue;
        int last = parts.Length - 1;
        if (parts[last].Length != 4 || parts[last - 1].Length != 6)
            return DateTime.MinValue;
        int datePart;
        if (!Int32.TryParse(parts[last - 1], out datePart))
            return DateTime.MinValue;
        int combinedChecksum;
        if (!Int32.TryParse(parts[last], out combinedChecksum))
            return DateTime.MinValue;

        int checkSum = CheckSum(GetBranding(true));
        if ((Math.Floor(Math.Sqrt(datePart)) + checkSum) % 10000 != combinedChecksum)
            return DateTime.MinValue;
        int dateNum = datePart + 40000; // days since Dec 30 1899
        var date = new DateTime(1899, 12, 30) + TimeSpan.FromDays(dateNum);

        // At one time there were some subscriptions which never ended. Those have been retired.
        if (date.Year == 3000)
            return DateTime.Parse(kExpiryDateForDeprecatedBrandings);
        return date;
    }

    // enhance extract and normalize the date part
    public bool GetChecksumCorrect()
    {
        if (Code == null)
            return false;
        var parts = Code.Split('-');
        if (parts.Length < 3)
            return false;
        int last = parts.Length - 1;
        if (parts[last].Length != 4 || parts[last - 1].Length != 6)
            return false;
        int datePart;
        if (!Int32.TryParse(parts[last - 1], out datePart))
            return false;
        int combinedChecksum;
        if (!Int32.TryParse(parts[last], out combinedChecksum))
            return false;

        int checkSum = CheckSum(GetBranding(true));
        if ((Math.Floor(Math.Sqrt(datePart)) + checkSum) % 10000 != combinedChecksum)
            return false;
        return true;
    }

    public bool IsExpired()
    {
        if (Code == null)
            return true;
        var date = GetExpirationDate();
        if (date == DateTime.MinValue)
            return true; // invalid code
        return date < DateTime.Now;
    }

    public bool LooksIncomplete()
    {
        if (Code == null)
            return true;
        var parts = Code.Split('-');
        if (parts.Length < 3)
            return true; // less than the required three components
        int last = parts.Length - 1;
        int dummy;
        if (!Int32.TryParse(parts[last - 1], out dummy))
            return true; // If they haven't started typing numbers, assume they're still in the name part, which could include a hyphen
        // If they've typed one number, we expect another. (Might not be true...ethnos-360-guatemala is incomplete...)
        // So, we already know the second-last part is a number, only short numbers or empty last part qualify as incomplete now.
        // Moreover, for the whole thing to be incomplete in this case, the completed number must be the right length; otherwise,
        // we consider it definitely wrong.
        if (
            parts[last - 1].Length == 6
            && parts[last].Length < 4
            && (parts[last].Length == 0 || Int32.TryParse(parts[last], out dummy))
        )
            return true;

        return false;
    }

    // Must match the function associated with the code generation google sheet
    private int CheckSum(string code)
    {
        var sum = 0;
        code = code.ToUpperInvariant();
        for (var i = 0; i < code.Length; i++)
        {
            sum += code[i] * i;
        }
        return sum;
    }

    public string GetIntegrityLabel()
    {
        if (String.IsNullOrWhiteSpace(Code))
        {
            return "none";
        }
        if (LooksIncomplete())
        {
            return "incomplete";
        }
        if (!GetChecksumCorrect())
        {
            return "invalid";
        }

        return "ok";
    }

    public SubscriptionTier Tier
    {
        get
        {
            if (TierOverride != null)
                return TierOverride.Value;
            var branding = GetBranding();
            if (string.IsNullOrWhiteSpace(branding) || branding == "Default")
                return SubscriptionTier.None;
            else if (
                branding == "Local-Community" || branding == "Local Community" /* pre 4.4 */
            )
                return SubscriptionTier.Community;
            else
                return SubscriptionTier.Enterprise;
        }
    }

    public string Personalization
    {
        // everything before the -LC- is the personalization code, e.g. "Foobar-Village". Replace dashes with spaces.
        get { return Code.Substring(0, Code.IndexOf("-LC-")).Replace("-", " "); }
    }

    // Enhance: soon we will devide up these so that they don't have exactly the same set of features
    public bool HaveActiveSubscription =>
        Tier == Subscription.SubscriptionTier.Enterprise
        || Tier == Subscription.SubscriptionTier.Community;

    internal bool IsDifferent(string code)
    {
        if (string.IsNullOrEmpty(Code) && string.IsNullOrEmpty(code))
            return false;
        return Code != code;
    }

    // Since normally all info comes from the code, this allows us to ignore the code and just set what we need.
    // If a unit test breaks because of an expired subscription, consider fixing it by using this method or one like it.
    public static Subscription ForUnitTestWithOverrideTierOrBranding(
        SubscriptionTier tier,
        string brandingKey
    )
    {
        var subscription = FromCollectionSettingsInfo("", brandingKey);
        subscription.TierOverride = tier;
        subscription.ExpirationDateOverride = DateTime.Now.AddDays(1);
        return subscription;
    }

    // Since normally all info comes from the code, this allows us to ignore the code and just set what we need.
    // If a unit test breaks because of an expired subscription, consider fixing it by using this method or one like it.
    public static Subscription ForUnitTestWithOverrideBranding(string brandingKey)
    {
        var subscription = FromCollectionSettingsInfo("", brandingKey);
        subscription.ExpirationDateOverride = DateTime.Now.AddDays(1);
        return subscription;
    }

    internal static Subscription ForUnitTestWithOverrideTier(SubscriptionTier tier)
    {
        var subscription = new Subscription("");
        subscription.TierOverride = tier;
        return subscription;
    }
}
