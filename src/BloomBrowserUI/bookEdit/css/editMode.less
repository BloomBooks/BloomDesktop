/*This stylesheet applied when a book is being edited. It does things like show that images can be changed by click on them.*/
@import "../../bloomUI.less";
@import "../sourceBubbles/sourceBubbles.less";

@bleed: 3mm; // Duplicated from basePage.less to remove circular dependency between BloomBrowserUI and content

@focusBorderColor: transparent; // #d6eaed; // @bloom-blue; // rgba(82, 168, 236, 0.6);
@tipLinkColor: #8e3581; // intentionally a bit darker to be legible

// should apply to everything, even dialogs.
body {
    --page-structure-color: #1d94a41a;
    --language-tag-color: #1d94a488;
    --selectedEdit-color: #1d94a4c2; //page structure color, but 76% opacity instead of 10%
    --unselectedEdit-color: #1d94a434; // page structure color, but 20% opacity instead of 10%
}

.bloom-page.cover {
    --page-structure-color: rgba(128, 128, 128, 0.268);
    --language-tag-color: rgba(128, 128, 128, 0.9);
    --selectedEdit-color: rgba(128, 128, 128, 0.9);
}
// This mixin simply encapsulates the logic of how we add a border on top
// of the edge of a bloom-canvas instead of adding a regular border
// which modifies the size of the container. See BL-10268.
.borderOnTopOfElement(@color) {
    &:after {
        border: 1px solid @color;
        content: "";
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        position: absolute;
        // this ":after" is actually on top of the whole image, including its description
        // if that is turned on. But we're only interested in putting a border around
        // the image; we don't want to intercept clicks on the image (or its description).
        pointer-events: none;
    }
}

@EditBoxItemsColor: #0000001a;
@MediumGray: #c0b9b9;
// For now we don't want this effect at all (BL-13895). Decided to keep the variable in case we change our minds.
@ImageAndVideoHoverOverlay: transparent;
@ImageButtonBorder: #716666;
@ChangeImageButtonColor: @ControlColor;
/*#0C8597; */
@OverflowColor: @WarningColor;
@MainPageBackgroundColor: #f8f8f8;
@PageDragBackgroundColor: #ffffa3;
@PageDragBorderColor: #c1e6ca;
@PageDragInnerItemBorderColor: #787800;

@PageLabelAndChangeLayoutPaneHeight: 45px;
@PageLabelVerticalDisplacement: -33px;

@imageDescriptionTopBorderWidth: 20px;

body {
    background-color: @bloom-darkestBackground;
    /* This works with a transform:scale style added in Javascript to allow zooming just the main page*/
    transform-origin: top left;
    // This was marked as working around a bug in Geckofx and that it should be removed when we weren't on
    // Geckofx anymore. However, its purpose is to keep the browser from having redraw errors during
    // Ctrl + mousewheel zooming and I saw some errors doing that, so I left it here.
    transition: transform 20ms;
}

// See comments on .bloom-mediaBox in basePage.less for a description of the mediaBox.
// Here, we are causing it to be visible when desired.
.bloom-mediaBox {
    pointer-events: none; // we want all clicks to go through this to the child

    & > * {
        pointer-events: auto; // start up clicks again a the next level
    }

    :not(.Device16x9Portrait):not(.Device16x9Landscape)&::before {
        // show bleed area
        content: "";
        position: absolute;
        left: 0;
        right: 0;

        top: 0;
        bottom: 0;
        border: 3mm solid rgba(0, 0, 0, 0.8);
        z-index: 1;
    }

    :not(.Device16x9Portrait):not(.Device16x9Landscape)&:after {
        // show safety area (the area inside of the trim box that still could get cut)
        content: "";
        position: absolute;
        left: @bleed;
        right: @bleed;
        top: @bleed;
        bottom: @bleed;
        border: 3mm solid rgba(0, 0, 0, 0.05);
        z-index: 2;
    }
}

#labelAndLayoutPane {
    height: @PageLabelAndChangeLayoutPaneHeight;
}

.tool-items:after {
    content: ".";
    display: block;
    height: 0;
    clear: both;
    visibility: hidden;
    font-size: 0;
}

.tool-items {
    display: inline-block;
}

.tool-items {
    /*\*/
    display: block;
    /**/
    -height: 1px;
}

// A special case for qtips that belong to Mui dialogs (current example is the Game Prompt dialog).
// These are not inside the scaling container where we usually put them, so we put the qtip in the body.
// That allows us to make a rule targeting just those tooltips when the dialog is hovered.
body:has(.MuiPaper-root:hover) > .qtip {
    opacity: 1 !important;
    transition: opacity 200ms ease-out;
}
// Now that most of our outline effects are conditional on the page being hovered, we get some sort of
// default on a focused content-editable div. It's an ugly solid black. When we're not hovering,
// we don't want any edit-only outlines at all, so the user can see the page as it will be.
// So we have this rule to suppress that default outline.
.bloom-page:not(:hover) .bloom-editable:focus {
    outline: none !important;
}

// Keep together here all the effects we want when hovering (previously: also when focus-within)
// the bloom-page. All of them need to also apply when the canvas element context controls are hovered,
// even though that is no longer a child of the bloom-page. (That's what the second rule is for.)
// The third rule is for the prompt input, which is not a child of the bloom-page.
// In that case, I don't think there's any reason to limit the effects to hovering; we're not wanting to
// show the user what the dialog will look like in the printed book.
.bloom-page:hover,
body:has(#canvas-element-context-controls:hover) .bloom-page,
#promptDialog {
    textarea,
    div.bloom-editable,
    div.pageLabel[contenteditable="true"] {
        outline: thin solid var(--unselectedEdit-color);
        outline-offset: -1px; // else the white of an un-focussed box can just bleed into the white of the margin
    }
    textarea:focus,
    div.bloom-editable:focus-within,
    div.pageLabel[contenteditable="true"]:focus {
        outline: 1px solid var(--selectedEdit-color) !important;
        outline-offset: -1px; // else the white of an un-focussed box can just bleed into the white of the margin
        // box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1),
        //     0 0 8px rgba(82, 168, 236, 0.6);
    }
    .bloom-canvas-element div.bloom-editable:focus, // not sure need this as well as the following, but it was here first
    .bloom-canvas-element[data-bloom-active="true"] div.bloom-editable {
        // editable in a canvas element has the control frame, so any outline just produces a double border
        outline: none !important;
    }
    // Any single outline/border color is not enough to always show up on all backgrounds.
    // So when the page is hovered, we add a thin white outline around the editable canvas element divs when
    // they are not active to ensure that the user can see their presence even without
    // any text being entered, and even if the faint blueish outline we put on the element
    // itself merges into the background. (On a white background, of course, the outline here
    // won't be visible. But then the  bluish one can be seen.)  See BL-14193.
    // A rule in base-page.less suppresses these (along with other borders) for canvas elements
    // that are have natural borders to make them visible (i.e., comic style is not 'none')
    // The :not(.drag-activity-play *) prevents this from showing up when playing a game (BL-14678).
    .bloom-canvas-element:not([data-bloom-active="true"]):not(.drag-activity-play
            *)
        div.bloom-editable:before {
        content: " ";
        position: absolute;
        z-index: -1;
        top: 0; // align it with the editable
        left: 0;
        // Make it the same size. Be careful about making it extend beyond the editable;
        // we had a bug where it caused the scrollWidth of the editable to be larger than the clientWidth,
        // causing spurious overflow indications. The outline is outside the editable, which is OK because
        // it doesn't count as part of the size, but a border (unless you calc a smaller size or use box-sizing:border-box)
        // would cause a problem, and a left: 1px might, too.
        height: 100%;
        width: 100%;
        pointer-events: none;
        outline: 1px solid white;
    }
    div.bloom-canvas {
        // Allow book templates to define a custom borderColor, otherwise fallback to the default color
        .borderOnTopOfElement(var(--page-structure-color));
        // todo: remove?                 --bloom-editMode-custom-image-border-color,

        // This shows the focus border on the bloom-canvas
        // when it has been clicked on to show its editing buttons (:not(.bloom-hideImageButtons)).
        // Currently, something else typically actually has focus and may also show
        // this border. But at least it gives some extra feedback that something happened
        // by clicking the background image.
        &.bloom-has-canvas-element:not(.bloom-hideImageButtons) {
            .borderOnTopOfElement(@focusBorderColor);
        }
    }
    .coverColor div.bloom-canvas {
        .borderOnTopOfElement(rgba(1, 1, 1, 0.2));
    }
    #formatButton {
        visibility: visible;

        margin-left: 3px;
        /*The font-size here is weird, but if we don't set it, the growing/shrinking font of the text will actually move the button up/down on the page*/
        font-size: 10pt;
        height: 20px;
        width: 20px;
        z-index: @formatButtonZIndex;

        img {
            position: absolute;
            bottom: 0;
            left: 0;
        }

        &:hover {
            color: black;
        }
    }

    /*Put in little grey language tooltips in the bottom-right of the editable divs*/
    .languageTip,
    .bloom-editable[contentEditable="true"][data-languageTipContent]:not([data-languageTipContent=""]):after {
        position: absolute;
        right: 0;
        /*Same grey color as pageLabel*/
        color: var(--language-tag-color); //rgba(0, 0, 0, 0.2);
        font-family: @UIFontStack;
        font-size: small;
        font-style: normal;
        font-weight: normal;
        line-height: 1; //else it will draw up in the box somewhere if the font is large
        text-shadow: none;
        content: attr(data-languageTipContent);
        bottom: 2px; // See Bl-10017
        margin-right: 2px;
    }
    // show some structure when the page is hovered
    // Show the padding, multilingual gap, etc as colored areas.
    // The ".split-pane-component-inner >"  disables this for canvas elements, where it's common to have backgrounds like transparent
    .split-pane-component-inner > .bloom-translationGroup {
        // no: a border here will take up space, wrecking WYSIWYG
        // border: solid thin var(--page-structure-color);
        // box-sizing: border-box;
        // Also, you'd think you could use outline instead, but it doesn't show on the side; the
        // children over it up because they are the full width of this parent.

        &:not(.bloom-background-gray) {
            background-color: var(--page-structure-color) !important;
        }

        // the parent translation group has the "page structure" color so we
        // normally want to have the edit box be white. Note however that in the case that
        // we have a grey box, we're giving up on structure color and just want it all to be grey.
        &:not(.bloom-background-gray) .bloom-editable {
            background-color: var(--marginBox-background-color) !important;
        }
    }
}

// The editing buttons are hidden when this class is added (currently by motion and comic tools)
// (An earlier version required them to be a direct child of the bloom-canvas, so as not to
// disable them for canvas element images. But now these buttons only occur on background images, which
// ARE child canvas elements. So we want the disabling there. We use important because the rule that makes
// them visible ever is very complex and has high specificity.
.bloom-canvas.bloom-hideImageButtons {
    .imageButton {
        display: none !important;
    }
}

/*....NB: we have 2 rules because some pageLabels may be within the margin box, some outside*/
.marginBox div.pageLabel {
    /*+placement:anchor-top-left -1px -29px;*/
    position: absolute;
    left: -1px;
    top: calc(@PageLabelVerticalDisplacement - 48);
}

[data-derived="originalCopyrightAndLicense"] {
    cite {
        &.missingOriginalTitle,
        &:hover {
            color: red;
            text-decoration: underline red;
            cursor: pointer;
        }
    }
}

.ui-missingCopyrightNotice {
    margin-bottom: 1em;

    a {
        background-color: white;
        border: solid 1px;
        border-radius: 5px;
        border-color: @tipLinkColor;
        padding: 4px;
        font-family: @UIFontStack;
        font-size: 10px;
        font-weight: bold;
        text-decoration: none;
        color: @tipLinkColor;
    }
}

.bloom-page .pageLabel {
    text-align: left;
    color: @ControlColor;
    position: absolute;
    left: 5mm;
    top: @PageLabelVerticalDisplacement;
    float: left;

    &[contenteditable="true"] {
        color: @ControlColor;
        padding: 0 2px;
        display: initial; // must see it to edit it (template pages)
    }

    display: none; // BL-7925
}

.evenPage div.pageLabel {
    margin-left: 2.5cm;
}

.oddPage div.pageLabel {
    margin-left: 1.3cm;
}

div.page {
    background-color: @MainPageBackgroundColor;
    border: medium outset black;
}

div.page.coverColor {
    background-color: @ImageAndVideoHoverOverlay;
    border: medium outset black;
}

/* We want divs which are used for editing to look just like textareas (e.g. border).
   For now, this readOnlyInTranslationMode is an indicator that this is editable,
   but there could be divs which are always editable... unfortunately we can't access
   the contentEditable thing itself. Note that borders are made transparent by the languagedisplay.css,
   and there is javascript which notices that transparent border and makes the field read-only.
*/
div.readOnlyInTranslationMode {
    border: thin solid @MediumGray;
}

// Since 'basePage.less' has a rule that puts the video placeholder in as a background image,
// '.customPage' is needed to add enough specificity here to override that rule.
body:not(.origami-drag) .customPage .bloom-videoContainer:hover,
body:not(.origami-drag) .bloom-canvas:hover {
    background-color: @ImageAndVideoHoverOverlay;
}

// The hovered bloom-canvas background is just distracting when the whole page is a bloom-canvas.
// One group of such cases is bloom games. We may want to suppress it for pages
// designed to have a full-bleed background for a comic, and perhaps others. I went for a
// minimal change for now. (Possibly obsolete: we're no longer doing this hover-background at all.)
.bloom-page[data-tool-id="game"] .bloom-canvas:hover {
    background-color: transparent;
}

@imageButtonHInset: 10px;
@imageButtonVInset: 5px;

.imageButton {
    width: 63px;
    height: 52px;
    z-index: @imageButtonZIndex;
    position: absolute;
    background-repeat: no-repeat;
    background-size: contain;
    background-position: center center;
    border: none; // agent stylesheet otherwise gives it one. Grrr.
    background-color: transparent;
    border-radius: 3px;
    // Sometimes when the page is reloaded the browser puts a really ugly border around a button,
    // apparently to indicate it is focused. This rule suppresses that.
    // We might want some other indication if we allow tabbing to focus these buttons,
    // but we haven't even set that up yet.
    outline: none;
    // These box-shadows are copied from MUI to make our look-and-feel more consistent.
    box-shadow: 0px 3px 1px -2px rgba(0, 0, 0, 0.2),
        0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12);
    &:hover {
        box-shadow: 0px 2px 4px -1px rgba(0, 0, 0, 0.2),
            0px 4px 5px 0px rgba(0, 0, 0, 0.14),
            0px 1px 10px 0px rgba(0, 0, 0, 0.12);
        // MUI makes the background of a hovered "contained" button a little darker.
        // There's no way to just slightly darken the background only of an svg img,
        // so we'll just darken the whole thing. The effect on the white areas is not
        // very noticeable.
        &:after {
            content: "";
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
            border-radius: 3px;
            background-color: rgba(0, 0, 0, 0.05);
        }
    }
    &:active {
        box-shadow: 0px 5px 5px -3px rgba(0, 0, 0, 0.2),
            0px 8px 10px 1px rgba(0, 0, 0, 0.14),
            0px 3px 14px 2px rgba(0, 0, 0, 0.12);
        &:after {
            // mui does something much more complicated involving an animation,
            // but this is a rough approximation of the end result.
            background-color: rgba(255, 255, 155, 0.15);
        }
    }

    &.changeImageButton {
        right: @imageButtonHInset;
        top: @imageButtonVInset;
        background-image: url("/bloom/bookEdit/img/ChangeImageButton.svg");
    }

    // BL-9976 JH - "We've gotten complaints that users click it and then are too confused and
    // start typing text in the wrong place."
    // &.imageDescriptionButton {
    //     left: 0;
    //     bottom: 0;
    //     background-color: @bloom-blue;
    //     background-image: url("/bloom/bookEdit/img/ImageDescriptionImageOverlayButton.svg");
    //     // sorry, this background-size is kinda arbitrary, and "49px 40px" works at full size, but if we ever make these
    //     //buttons shrink as the bloom-canvas shrinks, this will still work.
    //     background-size: 63%;
    // }
    &.chooseWidgetButton {
        right: @imageButtonHInset;
        top: @imageButtonVInset;
        background-color: @ChangeImageButtonColor;
        background-image: url("/bloom/bookEdit/img/browse.svg");
    }

    &.editMetadataButton {
        left: @imageButtonHInset;
        top: @imageButtonVInset;
        background-image: url("/bloom/bookEdit/img/imageMetaDataButton.svg") !important;

        &.imgMetadataProblem {
            background-color: transparent;
            // This relatively subtle missing indicator is replaced by a more prominent one
            // in an active background canvas element.
            background-image: url("/bloom/bookEdit/img/MissingInfoIndicator.svg") !important;
        }
    }
}

.moving .imageButton {
    display: none !important;
}

// In a bloom-canvas with an active background canvas element, show yet another form of the edit metadata icon
.bloom-canvas:has(.bloom-backgroundImage[data-bloom-active="true"]) {
    .editMetadataButton.imgMetadataProblem {
        background-image: url("/bloom/bookEdit/img/imageMissingMetaData.svg") !important;
    }
}
// In an active background canvas element, don't show the edit metadata icon if the image failed
// to load.  Clicking on it would just show an error message anyway, and the button would
// obscure part of the alt attribute error message.
.bloom-canavas:has(.bloom-backgroundImage:has(img.bloom-imageLoadError)) {
    .editMetadataButton.imgMetadataProblem {
        display: none !important;
    }
}

.bloom-imageContainer {
    container-type: inline-size;
    container-name: bloom-image-container;
}

// Hide these large buttons when the image isn't wide enough to hold them both.
// There are equivalent controls in the toolbar and its menu.
@container bloom-image-container (max-width: 160px) {
    .imageButton {
        display: none !important;
    }
}

// we need to inset the buttons a bit when the full bleed borders are showing
body.bloom-fullBleed {
    @inset: calc(@bleed * 2);

    .imageButton {
        &.changeImageButton {
            right: calc(@inset + @imageButtonHInset);
            top: calc(@inset + @imageButtonVInset);
        }

        &.chooseWidgetButton {
            right: calc(@inset + @imageButtonHInset);
            top: calc(@inset + @imageButtonVInset);
        }

        &.editMetadataButton {
            left: calc(@inset + @imageButtonHInset);
            top: calc(@inset + @imageButtonVInset);
        }
    }
}

.bloom-showImageDescriptions {
    // Don't want to deal with resizing the bloom-canvas while this tool is active,
    // nor with the size changes associated with picking a different image.
    // The extra layer of scaling does weird things I haven't fully understood
    // to the code that tries to keep the background image and canvas elements aligned.
    .imageButton,
    .split-pane-divider,
    .origami-toggle {
        display: none !important;
    }

    .bloom-canvas {
        .bloom-imageDescription {
            // Note: this rule has basically the same specificity as one in basePage.less
            // that sets top to zero. I think this one only wins because it comes later.
            // It would be better to include another class that actually indicates edit mode,
            // but we don't seem to have one.
            top: @imageDescriptionTopBorderWidth;
            height: calc(100% - @imageDescriptionTopBorderWidth);
        }
    }
}

@imageDescriptionBorderWidth: 3px;

.bloom-showImageDescriptions .bloom-page .bloom-canvas {
    // This produces the thin border on the left, bottom, and right of each image when the
    // image description tool is active.
    border-style: solid;
    border-color: @accordion-active-element;
    border-width: 0 @imageDescriptionBorderWidth @imageDescriptionBorderWidth
        @imageDescriptionBorderWidth;
    background-repeat: no-repeat;

    // This rule produces the border and icon at the top of each image when the image description tool is active
    &::before {
        content: "";
        position: relative;
        height: @imageDescriptionTopBorderWidth;
        width: 100%;
        display: block;
        background-color: @accordion-active-element;
        background-repeat: no-repeat;
        background-position: center;
        background-image: url("/bloom/bookEdit/toolbox/imageDescription/ImageDescriptionToolIcon.svg");
    }
}
// a wrapper div we add around the contents of a bloom-canvas except the image description,
// when we are showing image descriptions. Shrinks the image to the center of the left half
// of the container.
// We need this because if we scale the bloom-canvas itself, the description gets scaled as well.
// Even if we tried to apply a reverse transformation to the description, the place we want it is
// outside the scaled bloom-canvas, and we're hiding overflow on bloom-canvases (and need to,
// both for cropping images and in case canvas elements extend beyond the container).
// Conversely, I don't believe CSS provides a way to transform children relative to an anchor
// on each parent. We could conceivably compute a different transform for each child, but this is more
// straightforward and less error-prone.
.bloom-describedImage {
    // for a reason I haven't tracked down, the rule that usually does this doesn't work here.
    img[src="placeHolder.png"] {
        display: none;
    }
    height: 100%;
    width: 100%;
    transform-origin: center left;
    transform: scale(0.5, 0.5);
}

.bloom-videoContainer,
.bloom-widgetContainer {
    &.bloom-selected {
        border: solid 2px @bloom-yellow;
    }
}
.bloom-videoContainer:focus-visible {
    // we show the active video container in other ways, and the browser's focus ring is just distracting
    outline: none;
}
// We don't need the yellow border indicating the active video when the selected thing is a canvas element.
// We have a distinct mechanism for showing the selected canvas element.
// (We don't have canvas element widgets and probably won't ever, but I included them just in case.)
.bloom-canvas-element {
    .bloom-videoContainer,
    .bloom-widgetContainer {
        &.bloom-selected {
            border: none;
        }
    }
}

// while doing an origami drag, most canvas elements won't resize.
// If there's a background image (which will), hide the others (and the canvas
// or svg, which shows their graphics, and also won't resize).
// If not, it's probably less disturbing if they just stay where they are
// until the origami drag is finished.
.origami-drag {
    .bloom-canvas:has(.bloom-backgroundImage) {
        .bloom-canvas-element:not(.bloom-backgroundImage),
        .comical-generated {
            display: none !important;
        }
    }
}

.editMetadataButton,
.changeImageButton {
    // currently these buttons display only for active background images,
    // unless the metadata has a problem (i.e., basically is missing).
    display: none;
}

// And this one should ALWAYS show if there's a problem.
.editMetadataButton.imgMetadataProblem {
    display: block;
}

// in a hovered bloom-canvas, show the buttons if the background image is active,
// or if there are no other canvas elements. Also, show the metadata button if there's a
// problem.
.bloom-canvas:hover {
    &:not(:has(.bloom-canvas-element:not(.bloom-backgroundImage))),
    &:has(.bloom-backgroundImage[data-bloom-active="true"]) {
        .editMetadataButton,
        .changeImageButton {
            display: block;
        }
    }
    .editMetadataButton.imgMetadataProblem {
        display: block;
    }
}

// In a bloom-canvas that has canvas elements other than the background image, we want to
// hide the placeholder except when the background image is active.
.bloom-canvas:has(.bloom-canvas-element:not(.bloom-backgroundImage)) {
    .bloom-backgroundImage:not([data-bloom-active="true"]) {
        img[src^="placeHolder.png"] {
            display: none;
        }
    }
}

button.deleteButton {
    position: absolute;
    left: 0;
    bottom: 0;
    background-image: url("/bloom/bookEdit/img/deleteButtonSmall.png") !important;
    width: 40px;
    height: 40px;
    z-index: 100;
}

/*Originally, the move button was within the movable thing. Problem is, I couldn't get jquery draggable to actually use this button, using the 'handle' option, probably because it doesn't exist early enough (it pops up on mouseEnter) . But I had to have something in that option, else jquery actually prevents clicking on elements inside the drraggable thing. So I ended up setting the handle to "img", which won't be sufficient once we wan to drag things with no image.So it woud be good to get this working.*/
.moveButtonIcon {
    background-image: url("/bloom/bookEdit/img/moveDivButton.png") !important;
    width: 37px !important;
    height: 37px !important;
}

button.moveButton {
    /*+placement:anchor-top-left -19px -17px;*/
    position: absolute;
    left: -19px;
    top: -17px;
    background-image: url("/bloom/bookEdit/img/moveDivButton.png") !important;
    background-repeat: no-repeat;
    background-color: transparent;
    width: 16px;
    height: 16px;
    border: 0 hidden black;
    z-index: 1000;
    background-size: contain;
}

// I'm not sure why the rule above (JT: which one?) is !important, but this one has to be to beat it.
// In edit mode we don't want such an automatic outline, because the control frame
// provides one, and typically they don't even line up, becuase we grow the control
// frame a little bit to prevent the side buttons overlapping text.
// Note that, prior to 6.1, we also had two rules in overlayTool.less (in content) putting an outline
// and shadow on a focused bloom-editable in a canvas element. If we put that back for some
// reason, we'll need a box-shadow:none (maybe !important) here because it looks wrong
// with the wider control frame.
.bloom-canvas-element .bloom-editable:focus {
    outline: none !important;
}

.bloom-editable:focus {
    //position: relative;
    z-index: 1; // make room for the ¶ to show underneath the text

    // make paragraph markers visible
    p::after,
    .bloom-linebreak:after {
        color: @EditBoxItemsColor;
        position: absolute;
        right: 0;
        bottom: 0; // For the p::after case, this helps prevent the edit-time <br> elements from pushing the "¶ down onto the next (wrong) line
        // When this mark is added to a paragraph that has reduced line spacing, the browser considers it to overflow.
        // Thus, the potential descent of the paragraph mark (even though it has no descender) contributes to the para's scrollHeight,
        // since the bottom of the box (constrained by lineHeight) gets aligned with the bottom of the paragraph, so the
        // nonexistent descenders which are cut off by the lineheight are actually below the bottom of the paragraph.
        // This can actually add to the scrollHeight of the containing bloom-editable, resulting in Bloom concluding that it
        // is overflowing. But if we hide any overflow of the :after, this doesn't happen.
        // What is more surprising is that it actually seems to improve the alignment of the paragraph mark with the text.
        // I haven't figured out why this is. See some of the later comments in BL-11606.
        overflow: hidden;
        z-index: -1; // go under any text that reach the end of the line (I don't know why, but 0 doesn't work)
    }

    p::after {
        content: "¶";
    }

    .bloom-linebreak:after {
        content: "↲";
    }

    &[dir="rtl"] {
        p:after,
        .bloom-linebreak:after {
            right: auto;
            left: 0;
        }
    }
}

textarea.province {
    width: 151px;
    height: 33px;
}

/* somehow, this doesn't affect the layout of the page inside. */
div.bloom-templateMode {
    border: 3px dashed black;
}

// We only make a big deal out of "overflow" if the layout is a *paper* size, rather than a *device* size.
.bloom-page:not([class*="Device"]) {
    // We need this three times to beat a rule that gives the focusd editable box a blue outline
    .overflow.overflow.overflow {
        color: @OverflowColor !important;
        outline: solid thin @OverflowColor !important; //rather than border so it doesn't affect layout

        p:empty:after {
            //br:after would be great but it doesn't work
            content: "¶";
        }
    }
}

// The fix for the language label does not work with niceScroll, so I've commented it out.
// .bloom-page[class*="Device"] {
//     .bloom-editable.overflow {
//         overflow-y: scroll;
//
//         // the language label at the bottom gets messed up once scrolling is on, so anchor it to the top
//         &:after {
//             top: 0 !important;
//             bottom: unset !important;
//         }
//     }
// }

// We want a thick red line at the bottom. Outline can't do a line on just one side.
// We don't want a border on the box itself because that takes up space; a box that
// once starts overflowing might be stuck that way because of the extra space needed
// for the border. So we use a pseudo-element to draw the line.
.childOverflowingThis:after {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    box-sizing: border-box;
    pointer-events: none;
    border-bottom: solid thick @OverflowColor !important;
    // no, that's really confusing when text far from the crime turns red color: red !important;
}

//we do both in case one is already used and !important
.Layout-Problem-Detected:before,
.Layout-Problem-Detected:after {
    content: attr(layoutproblem);
    text-align: left;
    color: @OverflowColor;
    position: absolute;
    bottom: 0;
    left: 0;
    font-size: 9pt;
    line-height: 9pt;
}

.ui-tooltip-plain a {
    color: @tipLinkColor;
}

.fieldInfo-qtip .ui-tooltip-content {
    border: 0 solid #a03c50;
    padding: 0px;
    text-align: right;
    color: @bloom-darkestBackground;
    font-size: 8pt;
    margin-top: -8px;
    margin-right: 8px;
}

div.textWholePage ul {
    position: absolute;
    margin-left: 1px;
    margin-top: -37px;
}

/*suggested by http://jqueryui.com/docs/Upgrade_Guide_17*/
.ui-mouseOver .ui-resizable-handle {
    width: 8px;
    height: 8px;
    border: 1px solid rgb(128, 128, 128);
    background: rgb(242, 242, 242);
}

.ui-resizable-n,
.ui-resizable-s {
    left: 45%;
}

.ui-resizable-e,
.ui-resizable-w {
    top: 45%;
}

.bloom-frontMatter div.marginBox {
    /*With the colored background, the margin border is just too distracting, and it doesn't (yet) help the user in any way because he can't move things around on the frontmatter*/
    border: none;
}

//BL-2512 when overflowing on pages where the text is allowed to run off the screen, the formatButton would not be visible/reachable, so you couldn't shrink the text
//in response to the overflow situation.
//So in this situation, we just show it at the top.
.thisOverflowingParent #formatButton {
    top: 0;
}

#formatButton {
    visibility: hidden;
    overflow: hidden;
    position: absolute;
}

// Now sometimes, the format button lands under the page number.
// Changing the z-index did not help. So we allow themes to "dodge" it.
// Kind of a hack, I know. See BL-13206.
@container style(--pageNumber-show-multiplicand:1) {
    .split-pane-component.position-right
        .split-pane-component-inner
        > .bloom-translationGroup
        > #formatButton,
    .split-pane-component.position-top
        .split-pane-component-inner
        > .bloom-translationGroup
        > #formatButton {
        // don't need this dodge if the page number can't be in this text area
        --formatButton-pageNumber-dodge: 0px;
    }
    .split-pane-component.position-left
        > .split-pane-component-inner
        > .bloom-translationGroup
        > #formatButton,
    .split-pane-component.position-bottom
        > .split-pane-component-inner
        > .bloom-translationGroup
        > #formatButton,
    // text-only page
    .marginBox
        > .split-pane-component-inner
        > .bloom-translationGroup
        > #formatButton {
        // this "3px" is there from long ago, nothing to do with this nudging
        margin-left: calc(3px + var(--formatButton-pageNumber-dodge));
    }
}

/*Toolbox*/
#pagedragtoolbox {
    background-color: @PageDragBackgroundColor;
    position: relative;
    left: 564px;
    top: -649px;
    width: 274px;
    height: 645px;
}

.ui-resizable,
.ui-draggable,
.ui-deletable {
    border: 1px solid @PageDragBorderColor;
}

#pagedragtoolbox img {
    width: 116px;
}

#pagedragtoolbox > ul > li > div {
    border: 1px dotted @PageDragInnerItemBorderColor;
    margin-top: 34px;
    /*[empty]padding-top:;*/
}

ul.pagedragtoolbox {
    height: 212px;
    width: 207px;
    margin-left: 31px;
    margin-top: 15px;
    background-color: transparent;
}

ul.pagedragtoolbox li {
    display: inline-block;
    width: 162px;
}

textarea.Heading1-style,
div.bloom-editable.Heading1-style {
    font-size: 16pt;
}

textarea.Heading2-style,
div.bloom-editable.Heading2-style {
    font-size: 13pt;
    font-weight: bold;
}

.Bubble-style {
    /*  This (currently) empty style lets the Style dropdown find Bubble to add to its list.
        If we decide later, we could give it a default style different than normal.
        While it seems odd/wrong to put this in editMode.less (instead of Basic Book.less, for example),
        it has some advantages:
            1. It is placed with Heading1 and Heading2 above.
            2. It prevents the empty rule from getting deployed with the book unnecessarily.

        This type of comment allows the less compiler to keep the empty rule set. */
}

.centered {
    text-align: center;
}

.languageTip {
    visibility: hidden;
}

.languageTip {
    margin-right: 1px;
    text-align: right;
    bottom: 0;
}

/*Simulate the html5 placeholder attribute which is not available on divs
The :not(:focus) selector here is something we do NOT want. It was added as a workaround for a firefox bug
https://bugzilla.mozilla.org/show_bug.cgi?id=997749, namely that when the user clicks in an element which
has a :before rule applied and which already has focus, weird things happen and typing is suppressed.
When this bug is fixed, or if we can find a better workaround, the :not(:focus) should be removed
so that when a div has the data-placeholder attribute set, the placeholder will continue to appear
even when the div is focused (as long as it is empty).*/
[contentEditable="true"][data-placeholder]:empty:not(:focus):before {
    content: attr(data-placeholder);
    color: @bloom-buff;
}

/*This block handles marking elements that violate decodable book and leveled reader constraints*/
span.sentence-too-long {
    background-color: @LeveledReaderViolationColor;
    position: unset; // BL-11633, works around Chromium bug
}

span.word-too-long {
    background-color: @bloom-lightblue;
    position: unset; // BL-11633, works around Chromium bug
}

.page-too-many-words-or-sentences .marginBox {
    border: 5px solid @LeveledReaderViolationColor !important;
}

.book-too-many-unique-words .marginBox {
    border: 5px solid @LeveledReaderViolationColor !important;
}

.book-too-many-words .marginBox {
    border: 5px solid @LeveledReaderViolationColor !important;
}

.ui-dialog {
    z-index: 20000;
}

span.sight-word {
}

span.word-not-found {
    background-color: @DecodableReaderViolationColor;
    position: unset; // BL-11633, works around Chromium bug
}

div.bloom-editable {
    // Chrome 105 and later (ie, WebView2) has the :has selector.
    // These rules may not need the :has(span) selector, but I
    // don't want to risk breaking something.  This is enough to
    // work around the Chromium bug reported in BL-11633.
    span[style]:has(span),
    em:has(span),
    strong:has(span),
    u:has(span),
    sup:has(span) {
        position: unset; // BL-11633, works around Chromium bug
    }
}

/* We are disabling the "Possible Word" feature at this time.
SPAN.possible-word
{
    -moz-text-decoration-style: wavy;
    -moz-text-decoration-line: underline;
    -moz-text-decoration-color: blue;
}
*/

div.cke_float {
    div.cke_top {
        padding: 4px !important;

        span.cke_toolgroup {
            margin: 0 !important;
        }
    }
}

.bloom-canvas-element .bloom-editable {
    padding-top: 1px; // for some reason this is needed to keep edit/non-edit text spacing the same
}

div.long-press-popup {
    z-index: 15005;
}

// in front of hint bubbles

.bloom-videoOverlay {
    position: absolute;
    height: 100%;
    width: 100%;
    box-sizing: border-box;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 1; // the whole point is to hide the video underneath
    border: 4px dashed @bloom-blue;
    background: aliceblue;
    color: @bloom-blue;
    font-size: 40px;
    z-index: @baseZIndexForContainers + 50; // stay above videoContainer
}

// This seems to produce about the amount of yellowing and blurring and darkness
// seen in http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=0F77B0242324523646B4C8F5A0BDDA52?doi=10.1.1.656.6430&rep=rep1&type=pdf,
// particularly Figure 1, "Visual acuity chart showing the blurring and color effects of a disabling brunescent cataract with a visual acuity of 20/200"
body.simulateCataracts {
    .bloom-canvas {
        background-color: yellow;

        img,
        canvas {
            filter: blur(3px) brightness(50%);
            mix-blend-mode: multiply;
            font-size: 20px;
            background-color: white;
        }
    }
}

// Hide images when we are putting a color-blindness canvas element on top.
// This makes sure we don't get any trace if the size isn't perfect.
// More critically, when simulating BOTH color-blindness AND cataracts,
// the Canvas gets merged with what is behind it. We want that to be just
// the yellow background, not the image.
body.simulateColorBlindness {
    .bloom-canvas {
        img {
            visibility: hidden;
        }
    }
}

// I decided to take these out. The cog wheel is not very conspicuous and
// we already have code to make sure there's only one. The second rule
// is intented to make the cog visible (overriding the first one) when focus is in
// its translation group. It developed a problem when the cog moved outside the
// bloom-editable. Clicking the cog apparently causes the TG to lose focus,
// possibly because we're now clicking on something that is outside the
// (contenteditable) bloom-editable. Then the cog disappears without
// performing its click action.
// Hide the gear button unless the text box is focused for editing.
// #formatButton {
//     display: none;
// }

// using :focus-within works better than .cke-focus (See BL-11803.)
// .bloom-translationGroup:focus-within {
//     #formatButton {
//         display: inherit;
//     }
// }

// Moved from editOriginalMode.css when it became obsolete
//(no longer have original/translation=unlocked/locked modes)

ol#topics {
    list-style: none;
}

// There was a rule for bloom-readOnlyInAuthorMode, but this is obsolete
// There was also a file editTranslationMode, with a rule for bloom-readOnlyInTranslationMode,
// but the mode is obsolete so the rule has to be, even though we do still have one field so marked.

div.bloom-metaData {
    cursor: pointer;
    /*this signals to jscript that when the user clicks on this div, it should raise the message in data-message (which bloom will catch)*/
}

div.bloom-metaData textarea {
    /*border: transparent; /* jscript will translate to read only*/
    cursor: pointer;
    /*this signals to jscript that when the user clicks on this div, it should raise the message in data-message (which bloom will catch)*/
}

.enablePageCustomization div.marginBox {
    border: thin dotted rgba(133, 133, 193, 0.9) !important;
}

// end of block moved from editOriginalMode

// normally, the height is just a bit more than the paper size. We changed this in Bloom 5.5 so that we
// could make dialogs draggable but be constrained the the bounds of the body, without that meaning that
// you could only have the dialog in the top part of the screen that also had the page.
html,
body {
    height: 100%;
}

// Due to a Chromium bug, elements with our default relative position
// and a background color cause the caret not to show up. Somehow, this
// triggers when a decodable reader error span is nested inside one of these
// spans, even though when DR is active the rules that give these segments
// background color are not active. Nothing depends on thei being position:relative,
// so it's easiest to just prevent it. See BL-11633 for reproduction steps in Bloom 5.5.
.bloom-highlightSegment {
    position: unset;
}

// Don't show text over picture borders, resizing handles, or format buttons unless hovering over the image
// (This and several following rules were moved from content/bookLayout/overlayTool.less)
.bloom-canvas:not(:hover) .bloom-canvas-element {
    .bloom-editable {
        border: none;

        &:after {
            display: none !important;
        }
    }

    .ui-resizable-handle {
        display: none !important;
    }

    .bloom-dragHandle {
        display: none;
    }

    #formatButton {
        display: none;
    }

    .bloom-imageContainer {
        &:after {
            border: none; // overwrite rule from editMode.less
        }
    }
}

// This can color the svg into whatever color we want. Currently bloom-purple.
// While working on this PR I changed the color 4 times and it's a pain to keep
// exporting new svgs.
// Eventually if the color settles down, we can replace this with just svg's colored like we want.
// To generate new filter rules like this, use https://codepen.io/sosuke/pen/Pjoqqp
@ComicAffordanceFilter: invert(48%) sepia(14%) saturate(1147%)
    hue-rotate(257deg) brightness(90%) contrast(84%);

.bloom-canvas {
    .bloom-canvas-element {
        .bloom-translationGroup {
            #formatButton {
                &:hover {
                    background-color: white; // make it stand out more from the image behind
                }

                img {
                    // turns the cog purple to match other Comic affordances, without requiring
                    // a different SVG. (Don't do this to the whole button, it messes with
                    // the background too when it's not transparent, e.g., when hovered.)
                    filter: @ComicAffordanceFilter;
                }
            }
        }

        .bloom-dragHandle {
            filter: @ComicAffordanceFilter;
            position: absolute;
            left: unset;
            // NB: right is set by a rule at the end of this file
            width: 22px;
            height: 22px;
            top: -15px;
            // This z-index should be above the canvas
            z-index: @canvasElementDragHandleZIndex;
        }
    }
}

.bloom-canvas-element {
    #formatButton {
        display: none; // Enhance: maybe don't create at all?
    }
}

// different canvas element shapes require different positioning of the affordances
[data-bubble] {
    // These happen to be multiples of 1.4 is because they are 1% increments of 140px (the default text box width)
    .bloom-dragHandle {
        right: calc(100% + 1.4px);
    }

    [data-languageTipContent]:after {
        content: "" !important; // suppress these, now in canvas element context controls
    }
}

[data-bubble*="caption"] {
    [data-languageTipContent]:after {
        right: calc(100% + 2.8px) !important;
    }
}

// hideAllCKEditors is toggled by bloomEditing.ts to prevent bl-12448
body.hideAllCKEditors .cke_chrome {
    // "display" is manipulated on the `style` element by ckeditor, so we can't use that
    visibility: hidden;
}

// We have all kinds of code that knows placeHolder.png is special. So it's nontrivial to
// switch and use a different placeholder image for GIFs. However, some of that code we
// already have prevents showing the placeholder except while editing. So we can get the
// effect we want (a different placeholder for GIFs) by just making the placeholder src
// and changing the content of the image.
.bloom-gif img[src="placeHolder.png"] {
    content: url("/bloom/images/Gif.svg");
    opacity: 0.4;
}

.invisibles {
    font-family: "SymChar";
    color: @bloom-purple;
}

// ----- Bloom Games ----
// Tweak the position of the Start/Correct/Wrong/Play control
#drag-activity-tab-control {
    position: relative;
    top: -8px;
    width: 100%;
}

// we want :blank, but it's not in browsers yet. So we simulate it by a mutation observer
// that adds a class to the editable when it is empty.
// The data-place-holder-value gets set from the best available localization of
// data-placeholder-l10n-id or data-eager-placeholder-l10n-id.
// The :before is put on the paragraph so that it gets all the normal styling
// that the paragraph should have. (:after is sometimes already used for something).
// The blank-prompt variable makes it possible to use the text from the data-placeholder-value
// attribute as the content of a pseudo-element on a child element (the attr() function
// can only get an attribute from the current element, not a parent).
// Since bloom-blank is only added to empty elements, there would not normally be more than
// one paragraph in the parent, but first-child makes sure we we don't get multiple
// placeholders if there is a sequence of empty paragraphs.
[data-placeholder-value] {
    --blank-prompt: attr(data-placeholder-value);
    .bloom-blank p:first-child:before {
        content: var(--blank-prompt);
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none; // We can click right through it to the bloom-content1
        opacity: 40%; // dim a bit to make it look like a prompt.
        background-color: transparent;
    }
}

canvas.moving {
    cursor: move;
}

.bloom-canvas-element:not(.bloom-focusedCanvasElement) * {
    cursor: default;
}
.bloom-canvas-element.moving:not(.bloom-focusedCanvasElement) * {
    cursor: move;
}

@resizeHandleRadius: 8px;
@sideHandleRadius: 4px;
@sideHandleCenter: 6px;
// We place this frame over each canvas element to support resizing and cropping.
// The frame itself is invisible (and ignores pointer events), but it provides a container
// for the resize and crop handles and the toolbox below.
#canvas-element-control-frame {
    // Color for the various parts of the control frame. In a bloom-game page, we use the same
    // color as other rectangles. In particular we want to match the bloom-rectangle shape, because
    // that coincides with the control frame and looks strange if they are different colors.
    --canvas-element-control-color: var(
        --draggable-background-color,
        @bloom-blue
    );
    position: absolute;
    z-index: @canvasElementFrameZIndex;
    outline: 1px solid var(--canvas-element-control-color);
    // makes the outline no larger than the frame's own size, so it doesn't get cropped if it fills
    // the bloom-canvas, as background images do in at least one dimension. This means the outline
    // will hide the outermost pixel of the image, but I think that's better than the alternative of
    // having it cut off on one or two sides of a background image.
    outline-offset: -1px;
    box-sizing: border-box;
    pointer-events: none;
    background-color: transparent;

    // background images can't be manually resized
    &.bloom-backgroundImage-control-frame {
        .bloom-ui-canvas-element-resize-handle {
            display: none;
        }
    }

    // The handles and toolbox are hidden when the canvas element is being moved, resized or cropped
    // (except for the resize or crop control we are operating).
    &.moving {
        .bloom-ui-canvas-element-resize-handle,
        .bloom-ui-canvas-element-side-handle {
            display: none;
            &.active-control {
                display: block;
            }
        }
        &.bloom-ui-canvas-element-show-move-crop-handle {
            .bloom-ui-canvas-element-move-crop-handle {
                display: none;
            }
        }
    }
    // the "crop" handles on left and right are visible for text boxes
    // (though with a different function).
    &.has-text:not(.moving) {
        .bloom-ui-canvas-element-side-handle-e,
        .bloom-ui-canvas-element-side-handle-w {
            display: block;
        }
        // the south one is visible for text boxes only when auto-height is turned off.
        &.bloom-noAutoHeight .bloom-ui-canvas-element-side-handle-s {
            display: block;
        }
        // Enhance: Canva uses these handles on text boxes to resize the box by modifying
        // font size. This is nice for tweaking things but it's not clear how it should interact
        // with our style system. For now we're just not showing them for text boxes.
        .bloom-ui-canvas-element-resize-handle {
            display: none;
        }
    }

    // crop handles are, for now, only visible on images.
    .bloom-ui-canvas-element-side-handle {
        display: none; // default
        &.active-control {
            display: block;
        }
    }
    &.has-image:not(.moving):not(.has-svg)
        .bloom-ui-canvas-element-side-handle {
        display: block;
    }

    // The resize handles are the small circles in the four corners.
    // The move crop handle is the small circle in the center, used to change how an
    // image is cropped by (apparently) moving the image within the frame.
    .bloom-ui-canvas-element-resize-handle,
    .bloom-ui-canvas-element-move-crop-handle {
        position: absolute;
        width: @resizeHandleRadius * 2;
        height: @resizeHandleRadius * 2;
        border-radius: 50%;
        background-color: white;
        border: 1px solid var(--canvas-element-control-color);
        box-sizing: border-box;
        pointer-events: all;
        //z-index: @canvasZIndex + 2;
        &.active-control,
        &:hover {
            background-color: var(--canvas-element-control-color);
        }
    }
    .bloom-ui-canvas-element-resize-handle-nw {
        top: -@resizeHandleRadius;
        left: -@resizeHandleRadius;
        cursor: nw-resize;
    }
    .bloom-ui-canvas-element-resize-handle-ne {
        top: -@resizeHandleRadius;
        right: -@resizeHandleRadius;
        cursor: ne-resize;
    }
    .bloom-ui-canvas-element-resize-handle-sw {
        bottom: -@resizeHandleRadius;
        left: -@resizeHandleRadius;
        cursor: sw-resize;
    }
    .bloom-ui-canvas-element-resize-handle-se {
        bottom: -@resizeHandleRadius;
        right: -@resizeHandleRadius;
        cursor: se-resize;
    }

    .bloom-ui-canvas-element-move-crop-handle {
        top: calc(50% - @resizeHandleRadius);
        left: calc(50% - @resizeHandleRadius);
        display: none;
        cursor: move;
    }

    &.bloom-ui-canvas-element-show-move-crop-handle
        .bloom-ui-canvas-element-move-crop-handle {
        display: block;
    }

    // Used to crop images, but for text boxes the left and right ones are actually used to change width (and thus
    // aspect ratio).
    .bloom-ui-canvas-element-side-handle {
        position: absolute;
        width: @sideHandleRadius * 2;
        height: @sideHandleRadius * 2;
        border-radius: @sideHandleRadius;
        background-color: white;
        border: 1px solid var(--canvas-element-control-color);
        box-sizing: border-box;
        pointer-events: all;
        &.bloom-currently-cropped {
            background-color: var(--canvas-element-control-color);
        }
    }

    .bloom-ui-canvas-element-side-handle-n {
        top: -@sideHandleRadius;
        left: calc(50% - @sideHandleRadius - @sideHandleCenter);
        width: @sideHandleCenter * 2 + @sideHandleRadius * 2;
        cursor: ns-resize;
    }
    .bloom-ui-canvas-element-side-handle-e {
        top: calc(50% - @sideHandleRadius - @sideHandleCenter);
        right: -@sideHandleRadius;
        height: @sideHandleCenter * 2 + @sideHandleRadius * 2;
        cursor: ew-resize;
    }
    .bloom-ui-canvas-element-side-handle-s {
        bottom: -@sideHandleRadius;
        left: calc(50% - @sideHandleRadius - @sideHandleCenter);
        width: @sideHandleCenter * 2 + @sideHandleRadius * 2;
        cursor: ns-resize;
    }
    .bloom-ui-canvas-element-side-handle-w {
        top: calc(50% - @sideHandleRadius - @sideHandleCenter);
        left: -@sideHandleRadius;
        height: @sideHandleCenter * 2 + @sideHandleRadius * 2;
        cursor: ew-resize;
    }
    [data-title]:hover:after,
    [data-title]:active:after {
        // display the data-title like a title, but we will show it immediately,
        // and even while the mouse is down
        content: attr(data-title);
        position: absolute;
        top: 20px;
        left: 10px;
        background: white;
        border: 1px solid black;
        color: black;
        font-size: small;
        padding: 0.2em;
        z-index: 2;
        text-wrap-mode: nowrap;
    }
    // the tooltip may not be visible outside the frame, so
    // on the south and east sides we move it to the other side.
    .bloom-ui-canvas-element-side-handle-s:after {
        bottom: 20px;
        top: auto !important;
    }
    .bloom-ui-canvas-element-side-handle-e:after {
        right: 10px;
        left: auto !important;
    }

    // the background image is hard up against the side of the container on at least two edges,
    // and can't be moved. Half the default crop handle is clipped at best, and sometimes the
    // origami control gets in the way even more. So we move them inwards.
    &.bloom-backgroundImage-control-frame {
        .bloom-ui-canvas-element-side-handle-n {
            top: 1px;
        }
        .bloom-ui-canvas-element-side-handle-e {
            right: 1px;
        }
        .bloom-ui-canvas-element-side-handle-s {
            bottom: 1px;
        }
        .bloom-ui-canvas-element-side-handle-w {
            left: 1px;
        }
    }
}

#canvas-element-context-controls {
    position: absolute;
    transform-origin: top left;
    &.moving {
        display: none;
    }
    pointer-events: none; // overridden for children, but the outer bit that's just for positioning should not be clickable
}

#promptButton {
    visibility: hidden;
}

.drag-activity-start #promptButton {
    visibility: unset;
}

@videoIconSize: 30px;
@videoIconPadding: 0px;

div.bloom-videoControlContainer {
    position: absolute;
    top: calc(50% - @videoIconSize / 2);
    height: @videoIconSize + 2 * @videoIconPadding;
    width: @videoIconSize + 2 * @videoIconPadding;
    padding: @videoIconPadding;
    background-color: rgba(0, 0, 0, 0.5);
    border-radius: 50%;
    box-sizing: border-box;
    justify-content: center;
    align-items: center;
    display: none;
}

svg.bloom-videoControl {
    height: @videoIconSize;
}

// never shown at the same time, so same location is fine.
.bloom-videoPlayIcon,
.bloom-videoPauseIcon {
    left: calc(50% - @videoIconSize - 5px); // always the left of two icons
}

.bloom-videoReplayIcon {
    left: calc(50% + 5px); // always the right of two icons
}

// Show play and replay when paused
.bloom-videoContainer.paused {
    .bloom-videoControlContainer {
        &.bloom-videoPlayIcon,
        &.bloom-videoReplayIcon {
            display: flex;
        }
    }
}

// Show pause and replay when playing and hovered.
.bloom-videoContainer.playing:hover {
    .bloom-videoControlContainer {
        &.bloom-videoPauseIcon,
        &.bloom-videoReplayIcon {
            display: flex;
        }
    }
}

// Show play, centered, when hovering a video that is not paused or playing
.bloom-videoContainer:not(.paused):not(.playing):hover {
    .bloom-videoPlayIcon {
        display: flex;
        left: calc(50% - @videoIconSize / 2);
    }
}

// ...except in Game Play mode. This is tricky. It needs to override the rule above, but not
// override the rule that makes Play visible when we are paused. We could put a :not(.drag-activity-play)
// on the rule above, but I'm worried about the performance of a rule with a top-level negation.
// We could use !important here, but we really need at least the .drag-activity-play and
// the .bloom-videoContainer:not(.paused) or the !important will hide it when paused.
// (This rule would be more at home in Games.less, but we don't need any other Game-specific
// rules about the video controls, so I think it's more helpful to keep it with the rules
// it modifies.)
.drag-activity-play .bloom-videoContainer:not(.paused):not(.playing):hover {
    .bloom-videoPlayIcon {
        display: none;
    }
}

// If the background image hasn't been set in a game, we don't want to show the placeholder image.
.bloom-page[data-tool-id="game"]:not([data-activity="simple-dom-choice"])
    .bloom-backgroundImage
    img[src="placeHolder.png"] {
    visibility: hidden;
}
// We also want the crop handles to look disabled.  Disabling them is actually done in
// typescript code.  The pointer-events: none; seems not to work on the handle divs but
// is left as a reminder that we don't want to allow cropping in this case.  (BL-14703)
.bloom-page[data-tool-id="game"]:not([data-activity="simple-dom-choice"])
    #canvas-element-control-frame.bloom-backgroundImage-control-frame-no-image {
    .bloom-ui-canvas-element-side-handle,
    .bloom-ui-canvas-element-move-crop-handle {
        pointer-events: none;
        cursor: unset;
        opacity: 30%;
    }
}
.bloom-passive-element[data-bloom-active="true"]
    ~ .bloom-ui-canvas-element-resize-handle,
.bloom-passive-element[data-bloom-active="true"]
    ~ .bloom-ui-convas-element-side-handle,
.bloom-passive-element[data-bloom-active="true"]
    ~ .bloom-ui-canvas-element-move-crop-handle,
.bloom-passive-element[data-bloom-active="true"]
    ~ #canvas-element-control-frame {
    pointer-events: none;
    display: none;
}
#page-scaling-container:has(.bloom-passive-element[data-bloom-active="true"])
    ~ #canvas-element-context-controls {
    left: 160px;
    top: 80px;
    // Show only the first child of the context controls, which is the style button.
    span ~ span {
        display: none;
    }
    span ~ div {
        display: none;
    }
    span ~ button {
        display: none;
    }
}
