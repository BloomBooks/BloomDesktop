/*This stylesheet applied when a book is being edited. It does things like show that images can be changed by click on them.*/
@import "../../bloomUI.less";
@import "../sourceBubbles/sourceBubbles.less";

@bleed: 3mm; // Duplicated from basePage.less to remove circular dependency between BloomBrowserUI and content

@focusBorderColor: transparent; // #d6eaed; // @bloom-blue; // rgba(82, 168, 236, 0.6);
@tipLinkColor: #8e3581; // intentionally a bit darker to be legible

.bloom-page {
    --page-structure-color: #1d94a41a;
    --language-tag-color: #1d94a488;
    --selectedEdit-color: #1d94a4c2; //transparent;
    --unselectedEdit-color: #1d94a434; // page structure color, but 20% opacity instead of 10%
}

.bloom-page.cover {
    --page-structure-color: rgba(128, 128, 128, 0.268);
    --language-tag-color: rgba(128, 128, 128, 0.9);
    --selectedEdit-color: rgba(128, 128, 128, 0.9);
}
// This mixin simply encapsulates the logic of how we add a border on top
// of the edge of an image container instead of adding a regular border
// which modifies the size of the container. See BL-10268.
.borderOnTopOfElement(@color) {
    &:after {
        border: 1px solid @color;
        content: "";
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        position: absolute;
        // this ":after" is actually on top of the whole image, including its description
        // if that is turned on. But we're only interested in putting a border around
        // the image; we don't want to intercept clicks on the image (or its description).
        pointer-events: none;
    }
}

@EditBoxItemsColor: #0000001a;
@MediumGray: #c0b9b9;
// For now we don't want this effect at all (BL-13895). Decided to keep the variable in case we change our minds.
@ImageAndVideoHoverOverlay: transparent;
@ImageButtonBorder: #716666;
@ChangeImageButtonColor: @ControlColor;
@PasteImageButtonColor: @bloom-blue;
/*#0C8597; */
@MetadataButtonColor: #3a7f62; // the only place in .less files that any green is used
@OverflowColor: @WarningColor;
@MainPageBackgroundColor: #f8f8f8;
@PageDragBackgroundColor: #ffffa3;
@PageDragBorderColor: #c1e6ca;
@PageDragInnerItemBorderColor: #787800;

@PageLabelAndChangeLayoutPaneHeight: 45px;
@PageLabelVerticalDisplacement: -33px;

@imageDescriptionTopBorderWidth: 20px;

body {
    background-color: @bloom-darkestBackground;
    /* This works with a transform:scale style added in Javascript to allow zooming just the main page*/
    transform-origin: top left;
    // This was marked as working around a bug in Geckofx and that it should be removed when we weren't on
    // Geckofx anymore. However, its purpose is to keep the browser from having redraw errors during
    // Ctrl + mousewheel zooming and I saw some errors doing that, so I left it here.
    transition: transform 20ms;
}

// See comments on .bloom-mediaBox in basePage.less for a description of the mediaBox.
// Here, we are causing it to be visible when desired.
.bloom-mediaBox {
    pointer-events: none; // we want all clicks to go through this to the child

    & > * {
        pointer-events: auto; // start up clicks again a the next level
    }

    :not(.Device16x9Portrait):not(.Device16x9Landscape)&::before {
        // show bleed area
        content: "";
        position: absolute;
        left: 0;
        right: 0;

        top: 0;
        bottom: 0;
        border: 3mm solid rgba(0, 0, 0, 0.8);
        z-index: 1;
    }

    :not(.Device16x9Portrait):not(.Device16x9Landscape)&:after {
        // show safety area (the area inside of the trim box that still could get cut)
        content: "";
        position: absolute;
        left: @bleed;
        right: @bleed;
        top: @bleed;
        bottom: @bleed;
        border: 3mm solid rgba(0, 0, 0, 0.05);
        z-index: 2;
    }
}

#labelAndLayoutPane {
    height: @PageLabelAndChangeLayoutPaneHeight;
}

.tool-items:after {
    content: ".";
    display: block;
    height: 0;
    clear: both;
    visibility: hidden;
    font-size: 0;
}

.tool-items {
    display: inline-block;
}

.tool-items {
    /*\*/
    display: block;
    /**/
    -height: 1px;
}

// Now that most of our outline effects are conditional on the page being hovered, we get some sort of
// default on a focused content-editable div. It's an ugly solid black. When we're not hovering,
// we don't want any edit-only outlines at all, so the user can see the page as it will be.
// So we have this rule to suppress that default outline.
.bloom-page:not(:hover) .bloom-editable:focus {
    outline: none !important;
}

// Keep together here all the effects we want when hovering (previously: also when focus-within)
// the bloom-page. All of them need to also apply when the overlay context controls are hovered,
// even though that is no longer a child of the bloom-page. (That's what the second rule is for.)
.bloom-page:hover,
body:has(#overlay-context-controls:hover) .bloom-page {
    textarea,
    div.bloom-editable,
    div.pageLabel[contenteditable="true"] {
        outline: thin solid var(--unselectedEdit-color);
        outline-offset: -1px; // else the white of an un-focussed box can just bleed into the white of the margin
    }
    textarea:focus,
    div.bloom-editable:focus,
    div.pageLabel[contenteditable="true"]:focus {
        outline: 1px solid var(--selectedEdit-color) !important;
        outline-offset: -1px; // else the white of an un-focussed box can just bleed into the white of the margin
        // box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1),
        //     0 0 8px rgba(82, 168, 236, 0.6);
    }
    .bloom-textOverPicture div.bloom-editable:focus {
        // editable in an overlay has the control frame, so any outline just produces a double border
        outline: none !important;
    }
    div.bloom-imageContainer {
        // Allow book templates to define a custom borderColor, otherwise fallback to the default color
        .borderOnTopOfElement(var(--page-structure-color));
        // todo: remove?                 --bloom-editMode-custom-image-border-color,

        // This shows the focus border on the root (hasOverlay) image container
        // when it has been clicked on to show its editing buttons (:not(.bloom-hideImageButtons)).
        // Currently, something else typically actually has focus and may also show
        // this border. But at least it gives some extra feedback that something happened
        // by clicking the background image.
        &.hasOverlay:not(.bloom-hideImageButtons) {
            .borderOnTopOfElement(@focusBorderColor);
        }
    }
    .coverColor div.bloom-imageContainer {
        .borderOnTopOfElement(rgba(1, 1, 1, 0.2));
    }
    #formatButton {
        visibility: visible;

        margin-left: 3px;
        /*The font-size here is weird, but if we don't set it, the growing/shrinking font of the text will actually move the button up/down on the page*/
        font-size: 10pt;
        height: 20px;
        width: 20px;
        z-index: @formatButtonZIndex;

        img {
            position: absolute;
            bottom: 0;
            left: 0;
        }

        &:hover {
            color: black;
        }
    }
    .qtip {
        opacity: 1 !important;
        transition: opacity 200ms ease-out;
    }
    /*Put in little grey language tooltips in the bottom-right of the editable divs*/
    .languageTip,
    .bloom-editable[contentEditable="true"][data-languageTipContent]:not([data-languageTipContent=""]):after {
        position: absolute;
        right: 0;
        /*Same grey color as pageLabel*/
        color: var(--language-tag-color); //rgba(0, 0, 0, 0.2);
        font-family: @UIFontStack;
        font-size: small;
        font-style: normal;
        font-weight: normal;
        line-height: 1; //else it will draw up in the box somewhere if the font is large
        text-shadow: none;
        content: attr(data-languageTipContent);
        bottom: 2px; // See Bl-10017
        margin-right: 2px;
    }
    // show some structure when the page is hovered
    // Show the padding, multilingual gap, etc as colored areas.
    // The ".split-pane-component-inner >"  disables this for overlays, where it's common to have backgrounds like transparent
    .split-pane-component-inner > .bloom-translationGroup {
        // no: a border here will take up space, wrecking WYSIWYG
        // border: solid thin var(--page-structure-color);
        // box-sizing: border-box;
        // Also, you'd think you could use outline instead, but it doesn't show on the side; the
        // children over it up because they are the full width of this parent.

        &:not(.bloom-background-gray) {
            background-color: var(--page-structure-color) !important;
        }

        // the parent translation group has the "page structure" color so we
        // normally want to have the edit box be white. Note however that in the case that
        // we have a grey box, we're giving up on structure color and just want it all to be grey.
        &:not(.bloom-background-gray) .bloom-editable {
            background-color: var(--marginBox-background-color) !important;
        }
    }
}

// The editing buttons are hidden when this class is added (currently by motion and comic tools)
.bloom-imageContainer.bloom-hideImageButtons {
    > .imageButton,
    > .miniButton {
        display: none;
    }
}

/*....NB: we have 2 rules because some pageLabels may be within the margin box, some outside*/
.marginBox div.pageLabel {
    /*+placement:anchor-top-left -1px -29px;*/
    position: absolute;
    left: -1px;
    top: calc(@PageLabelVerticalDisplacement - 48);
}

[data-derived="originalCopyrightAndLicense"] {
    cite {
        &.missingOriginalTitle,
        &:hover {
            color: red;
            text-decoration: underline red;
            cursor: pointer;
        }
    }
}

.ui-missingCopyrightNotice {
    margin-bottom: 1em;

    a {
        background-color: white;
        border: solid 1px;
        border-radius: 5px;
        border-color: @tipLinkColor;
        padding: 4px;
        font-family: @UIFontStack;
        font-size: 10px;
        font-weight: bold;
        text-decoration: none;
        color: @tipLinkColor;
    }
}

.bloom-page .pageLabel {
    text-align: left;
    color: @ControlColor;
    position: absolute;
    left: 5mm;
    top: @PageLabelVerticalDisplacement;
    float: left;

    &[contenteditable="true"] {
        color: @ControlColor;
        padding: 0 2px;
        display: initial; // must see it to edit it (template pages)
    }

    display: none; // BL-7925
}

.evenPage div.pageLabel {
    margin-left: 2.5cm;
}

.oddPage div.pageLabel {
    margin-left: 1.3cm;
}

div.page {
    background-color: @MainPageBackgroundColor;
    border: medium outset black;
}

div.page.coverColor {
    background-color: @ImageAndVideoHoverOverlay;
    border: medium outset black;
}

/* We want divs which are used for editing to look just like textareas (e.g. border).
   For now, this readOnlyInTranslationMode is an indicator that this is editable,
   but there could be divs which are always editable... unfortunately we can't access
   the contentEditable thing itself. Note that borders are made transparent by the languagedisplay.css,
   and there is javascript which notices that transparent border and makes the field read-only.
*/
div.readOnlyInTranslationMode {
    border: thin solid @MediumGray;
}

// Since 'basePage.less' has a rule that puts the video placeholder in as a background image,
// '.customPage' is needed to add enough specificity here to override that rule.
body:not(.origami-drag) .customPage .bloom-videoContainer.hoverUp,
body:not(.origami-drag) .bloom-imageContainer.hoverUp {
    background-color: @ImageAndVideoHoverOverlay;
}

// The hovered image container background is just distracting when the whole page is an image
// container. One group of such cases is bloom games. We may want to suppress it for pages
// designed to have a full-bleed background for a comic, and perhaps others. I went for a
// minimal change for now.
.bloom-page[data-tool-id="game"] .bloom-imageContainer.hoverUp {
    background-color: transparent;
}

.imageButton {
    width: 87px;
    height: 52px;
    z-index: @dragHandleEventZIndex;
    position: absolute;
    background-repeat: no-repeat;
    background-size: contain;
    background-position: center center;

    &.smallButtonWidth {
        width: 50%;
        max-width: 87px;
        border-style: none;
    }

    &.smallButtonHeight {
        height: 50%;
        max-height: 52px;
        border-style: none;
    }

    &.changeImageButton {
        right: 0;
        top: 0;
        background-color: @ChangeImageButtonColor;
        background-image: url("/bloom/bookEdit/img/changeButton.svg");
    }

    // BL-9976 JH - "We've gotten complaints that users click it and then are too confused and
    // start typing text in the wrong place."
    // &.imageDescriptionButton {
    //     left: 0;
    //     bottom: 0;
    //     background-color: @bloom-blue;
    //     background-image: url("/bloom/bookEdit/img/ImageDescriptionImageOverlayButton.svg");
    //     // sorry, this background-size is kinda arbitrary, and "49px 40px" works at full size, but if we ever make these
    //     //buttons shrink as the image container shrinks, this will still work.
    //     background-size: 63%;
    // }
    &.chooseWidgetButton {
        right: 0;
        top: 0;
        background-color: @ChangeImageButtonColor;
        background-image: url("/bloom/bookEdit/img/browse.svg");
    }

    &.pasteImageButton {
        right: 0;
        bottom: 0;
        background-color: @PasteImageButtonColor;
        background-image: url("/bloom/bookEdit/img/pasteButton.svg");
        background-position: right center;

        &.smallButtonWidth {
            width: 87px;

            &.verySmallButtons {
                width: 98%;
                background-size: 60%;
            }
        }
    }

    &.editMetadataButton {
        left: 0;
        top: 0;
        background-image: url("/bloom/bookEdit/img/imageMetaDataButton.svg") !important;
        background-color: @MetadataButtonColor;

        &.imgMetadataProblem {
            background-color: transparent;
            background-image: url("/bloom/bookEdit/img/imageMissingMetaData.svg") !important;
            border: none;
        }
    }
}

// we need to inset the buttons a bit when the full bleed borders are showing
body.bloom-fullBleed {
    @inset: calc(@bleed * 2);

    // little cut and copy buttons
    .miniButton {
        right: calc(60px + @inset) !important;

        &.cutImageButton {
            bottom: calc(27px + @inset) !important;
        }

        &.copyImageButton {
            bottom: calc(6px + @inset);
        }
    }

    .imageButton {
        &.changeImageButton {
            right: @inset;
            top: @inset;
        }

        &.chooseWidgetButton {
            right: @inset;
            top: @inset;
        }

        &.pasteImageButton {
            right: @inset;
            bottom: @inset;
        }

        &.editMetadataButton {
            left: @inset;
            top: @inset;
        }
    }
}

// override button positions when the image is shrunk to make room for an image description
.bloom-showImageDescriptions {
    canvas {
        display: none;
    }

    .imageButton {
        &.changeImageButton,
        &.pasteImageButton {
            right: 50%;
        }

        &.changeImageButton,
        &.editMetadataButton {
            top: @imageDescriptionTopBorderWidth; // below the ::before border
        }
    }

    button.miniButton {
        right: calc(50% + 60px);

        &.verySmallButtons {
            // normally right:60%, width: 30%.
            // We need the effect of 60% of the picture half, plus the 50%
            // occupied by the text, that is, 30%+50%
            right: 80%;
            width: 15%;
        }
    }

    .bloom-imageContainer {
        // Requiring a direct child helps prevent this from applying to things like the format cog
        > img {
            height: calc(100% - @imageDescriptionTopBorderWidth);
        }

        .bloom-imageDescription {
            // Note: this rule has basically the same specificity as one in basePage.less
            // that sets top to zero. I think this one only wins because it comes later.
            // It would be better to include another class that actually indicates edit mode,
            // but we don't seem to have one.
            top: @imageDescriptionTopBorderWidth;
            height: calc(100% - @imageDescriptionTopBorderWidth);
        }
    }
}

@imageDescriptionBorderWidth: 3px;

.bloom-showImageDescriptions .bloom-page .bloom-imageContainer {
    // This produces the thin border on the left, bottom, and right of each image when the
    // image description tool is active.
    border-style: solid;
    border-color: @accordion-active-element;
    border-width: 0 @imageDescriptionBorderWidth @imageDescriptionBorderWidth
        @imageDescriptionBorderWidth;
    background-repeat: no-repeat;

    // This rule produces the border and icon at the top of each image when the image description tool is active
    &::before {
        content: "";
        position: relative;
        height: @imageDescriptionTopBorderWidth;
        width: 100%;
        display: block;
        background-color: @accordion-active-element;
        background-repeat: no-repeat;
        background-position: center;
        background-image: url("/bloom/bookEdit/toolbox/imageDescription/ImageDescriptionToolIcon.svg");
    }
}

.bloom-videoContainer,
.bloom-widgetContainer {
    &.bloom-selected {
        border: solid 2px @bloom-yellow;
    }
}

.hoverUp .imageButton {
    border: 2px outset @ImageButtonBorder !important;
    border-radius: 3px !important;

    &:hover {
        border: inset @ImageButtonBorder !important;
    }

    &.editMetadataButton {
        background-image: none;
        background-color: @MetadataButtonColor !important;
    }
}

button.miniButton {
    width: 20px;
    height: 18px;
    right: 60px;
    border: none;
    position: absolute;
    background-position: left center;
    background-repeat: no-repeat;
    background-size: contain;
    background-color: transparent;
    z-index: @miniImageEditingButtonZIndex;

    &:hover {
        border: 1px inset @ImageButtonBorder;
    }

    &.verySmallButtons {
        right: 60%;
    }

    &.smallButtonHeight {
        height: 15%;
    }

    &.verySmallButtons {
        width: 30%;
    }

    &.cutImageButton {
        background-image: url("/bloom/bookEdit/img/cut.svg");
        bottom: 27px;

        &.disabled {
            background-image: url("/bloom/bookEdit/img/cutGrey.svg");
            pointer-events: none;
        }

        &.smallButtonHeight {
            bottom: 26%;
        }
    }

    &.copyImageButton {
        background-image: url("/bloom/bookEdit/img/copy.svg");
        bottom: 6px;

        &.disabled {
            background-image: url("/bloom/bookEdit/img/copyGrey.svg");
            pointer-events: none;
        }

        &.smallButtonHeight {
            bottom: 4%;
        }
    }
}

button.deleteButton {
    position: absolute;
    left: 0;
    bottom: 0;
    background-image: url("/bloom/bookEdit/img/deleteButtonSmall.png") !important;
    width: 40px;
    height: 40px;
    z-index: 100;
}

/*Originally, the move button was within the movable thing. Problem is, I couldn't get jquery draggable to actually use this button, using the 'handle' option, probably because it doesn't exist early enough (it pops up on mouseEnter) . But I had to have something in that option, else jquery actually prevents clicking on elements inside the drraggable thing. So I ended up setting the handle to "img", which won't be sufficient once we wan to drag things with no image.So it woud be good to get this working.*/
.moveButtonIcon {
    background-image: url("/bloom/bookEdit/img/moveDivButton.png") !important;
    width: 37px !important;
    height: 37px !important;
}

button.moveButton {
    /*+placement:anchor-top-left -19px -17px;*/
    position: absolute;
    left: -19px;
    top: -17px;
    background-image: url("/bloom/bookEdit/img/moveDivButton.png") !important;
    background-repeat: no-repeat;
    background-color: transparent;
    width: 16px;
    height: 16px;
    border: 0 hidden black;
    z-index: 1000;
    background-size: contain;
}

img.hoverUp {
    outline: 1px outset black;
}

// I'm not sure why the rule above is !important, but this one has to be to beat it.
// In edit mode we don't want such an automatic outline, because the control frame
// provides one, and typically they don't even line up, becuase we grow the control
// frame a little bit to prevent the side buttons overlapping text.
// Note that, prior to 6.1, we also had two rules in bubble.less (in content) putting an outline
// and shadow on a focused bloom-editable in an overlay. If we put that back for some
// reason, we'll need a box-shadow:none (maybe !important) here because it looks wrong
// with the wider control frame.
.bloom-textOverPicture .bloom-editable:focus {
    outline: none !important;
}

.bloom-editable:focus {
    //position: relative;
    z-index: 1; // make room for the ¶ to show underneath the text

    // make paragraph markers visible
    p::after,
    .bloom-linebreak:after {
        color: @EditBoxItemsColor;
        position: absolute;
        right: 0;
        bottom: 0; // For the p::after case, this helps prevent the edit-time <br> elements from pushing the "¶ down onto the next (wrong) line
        // When this mark is added to a paragraph that has reduced line spacing, the browser considers it to overflow.
        // Thus, the potential descent of the paragraph mark (even though it has no descender) contributes to the para's scrollHeight,
        // since the bottom of the box (constrained by lineHeight) gets aligned with the bottom of the paragraph, so the
        // nonexistent descenders which are cut off by the lineheight are actually below the bottom of the paragraph.
        // This can actually add to the scrollHeight of the containing bloom-editable, resulting in Bloom concluding that it
        // is overflowing. But if we hide any overflow of the :after, this doesn't happen.
        // What is more surprising is that it actually seems to improve the alignment of the paragraph mark with the text.
        // I haven't figured out why this is. See some of the later comments in BL-11606.
        overflow: hidden;
        z-index: -1; // go under any text that reach the end of the line (I don't know why, but 0 doesn't work)
    }

    p::after {
        content: "¶";
    }

    .bloom-linebreak:after {
        content: "↲";
    }

    &[dir="rtl"] {
        p:after,
        .bloom-linebreak:after {
            right: auto;
            left: 0;
        }
    }
}

textarea.province {
    width: 151px;
    height: 33px;
}

/* somehow, this doesn't affect the layout of the page inside. */
div.bloom-templateMode {
    border: 3px dashed black;
}

// We only make a big deal out of "overflow" if the layout is a *paper* size, rather than a *device* size.
.bloom-page:not([class*="Device"]) {
    .overflow {
        color: @OverflowColor !important;
        border: solid thin @OverflowColor !important; //NB: can't afford to go "thick" because it throws off the calculation

        p:empty:after {
            //br:after would be great but it doesn't work
            content: "¶";
        }
    }
}

.bloom-page[class*="Device"] {
    .bloom-editable.overflow {
        overflow-y: scroll;

        // the language label at the bottom gets messed up once scrolling is on, so anchor it to the top
        &:after {
            top: 0 !important;
            bottom: unset !important;
        }
    }
}

.childOverflowingThis {
    border-bottom: solid thick @OverflowColor !important;
    // no, that's really confusing when text far from the crime turns red color: red !important;
}

//we do both in case one is already used and !important
.Layout-Problem-Detected:before,
.Layout-Problem-Detected:after {
    content: attr(layoutproblem);
    text-align: left;
    color: @OverflowColor;
    position: absolute;
    bottom: 0;
    left: 0;
    font-size: 9pt;
    line-height: 9pt;
}

.ui-tooltip-plain a {
    color: @tipLinkColor;
}

.fieldInfo-qtip .ui-tooltip-content {
    border: 0 solid #a03c50;
    padding: 0px;
    text-align: right;
    color: @bloom-darkestBackground;
    font-size: 8pt;
    margin-top: -8px;
    margin-right: 8px;
}

div.textWholePage ul {
    position: absolute;
    margin-left: 1px;
    margin-top: -37px;
}

/*suggested by http://jqueryui.com/docs/Upgrade_Guide_17*/
.ui-mouseOver .ui-resizable-handle {
    width: 8px;
    height: 8px;
    border: 1px solid rgb(128, 128, 128);
    background: rgb(242, 242, 242);
}

.ui-resizable-n,
.ui-resizable-s {
    left: 45%;
}

.ui-resizable-e,
.ui-resizable-w {
    top: 45%;
}

.bloom-frontMatter div.marginBox {
    /*With the colored background, the margin border is just too distracting, and it doesn't (yet) help the user in any way because he can't move things around on the frontmatter*/
    border: none;
}

//BL-2512 when overflowing on pages where the text is allowed to run off the screen, the formatButton would not be visible/reachable, so you couldn't shrink the text
//in response to the overflow situation.
//So in this situation, we just show it at the top.
.thisOverflowingParent #formatButton {
    top: 0;
}

#formatButton {
    visibility: hidden;
    overflow: hidden;
    position: absolute;
}

// Now sometimes, the format button lands under the page number.
// Changing the z-index did not help. So we allow themes to "dodge" it.
// Kind of a hack, I know. See BL-13206.
@container style(--pageNumber-show-multiplicand:1) {
    .split-pane-component.position-right
        .split-pane-component-inner
        > .bloom-translationGroup
        > #formatButton,
    .split-pane-component.position-top
        .split-pane-component-inner
        > .bloom-translationGroup
        > #formatButton {
        // don't need this dodge if the page number can't be in this text area
        --formatButton-pageNumber-dodge: 0px;
    }
    .split-pane-component.position-left
        > .split-pane-component-inner
        > .bloom-translationGroup
        > #formatButton,
    .split-pane-component.position-bottom
        > .split-pane-component-inner
        > .bloom-translationGroup
        > #formatButton,
    // text-only page
    .marginBox
        > .split-pane-component-inner
        > .bloom-translationGroup
        > #formatButton {
        // this "3px" is there from long ago, nothing to do with this nudging
        margin-left: calc(3px + var(--formatButton-pageNumber-dodge));
    }
}

/*Toolbox*/
#pagedragtoolbox {
    background-color: @PageDragBackgroundColor;
    position: relative;
    left: 564px;
    top: -649px;
    width: 274px;
    height: 645px;
}

.ui-resizable,
.ui-draggable,
.ui-deletable {
    border: 1px solid @PageDragBorderColor;
}

#pagedragtoolbox img {
    width: 116px;
}

#pagedragtoolbox > ul > li > div {
    border: 1px dotted @PageDragInnerItemBorderColor;
    margin-top: 34px;
    /*[empty]padding-top:;*/
}

ul.pagedragtoolbox {
    height: 212px;
    width: 207px;
    margin-left: 31px;
    margin-top: 15px;
    background-color: transparent;
}

ul.pagedragtoolbox li {
    display: inline-block;
    width: 162px;
}

textarea.Heading1-style,
div.bloom-editable.Heading1-style {
    font-size: 16pt;
}

textarea.Heading2-style,
div.bloom-editable.Heading2-style {
    font-size: 13pt;
    font-weight: bold;
}

.Bubble-style {
    /*  This (currently) empty style lets the Style dropdown find Bubble to add to its list.
        If we decide later, we could give it a default style different than normal.
        While it seems odd/wrong to put this in editMode.less (instead of Basic Book.less, for example),
        it has some advantages:
            1. It is placed with Heading1 and Heading2 above.
            2. It prevents the empty rule from getting deployed with the book unnecessarily.

        This type of comment allows the less compiler to keep the empty rule set. */
}

.centered {
    text-align: center;
}

.languageTip {
    visibility: hidden;
}

.languageTip {
    margin-right: 1px;
    text-align: right;
    bottom: 0;
}

/*Simulate the html5 placeholder attribute which is not available on divs
The :not(:focus) selector here is something we do NOT want. It was added as a workaround for a firefox bug
https://bugzilla.mozilla.org/show_bug.cgi?id=997749, namely that when the user clicks in an element which
has a :before rule applied and which already has focus, weird things happen and typing is suppressed.
When this bug is fixed, or if we can find a better workaround, the :not(:focus) should be removed
so that when a div has the data-placeholder attribute set, the placeholder will continue to appear
even when the div is focused (as long as it is empty).*/
[contentEditable="true"][data-placeholder]:empty:not(:focus):before {
    content: attr(data-placeholder);
    color: @bloom-buff;
}

/*This block handles marking elements that violate decodable book and leveled reader constraints*/
span.sentence-too-long {
    background-color: @LeveledReaderViolationColor;
    position: unset; // BL-11633, works around Chromium bug
}

span.word-too-long {
    background-color: @bloom-lightblue;
    position: unset; // BL-11633, works around Chromium bug
}

.page-too-many-words-or-sentences .marginBox {
    border: 5px solid @LeveledReaderViolationColor !important;
}

.book-too-many-unique-words .marginBox {
    border: 5px solid @LeveledReaderViolationColor !important;
}

.book-too-many-words .marginBox {
    border: 5px solid @LeveledReaderViolationColor !important;
}

.ui-dialog {
    z-index: 20000;
}

span.sight-word {
}

span.word-not-found {
    background-color: @DecodableReaderViolationColor;
    position: unset; // BL-11633, works around Chromium bug
}

div.bloom-editable {
    // Chrome 105 and later (ie, WebView2) has the :has selector.
    // These rules may not need the :has(span) selector, but I
    // don't want to risk breaking something.  This is enough to
    // work around the Chromium bug reported in BL-11633.
    span[style]:has(span),
    em:has(span),
    strong:has(span),
    u:has(span),
    sup:has(span) {
        position: unset; // BL-11633, works around Chromium bug
    }
}

/* We are disabling the "Possible Word" feature at this time.
SPAN.possible-word
{
    -moz-text-decoration-style: wavy;
    -moz-text-decoration-line: underline;
    -moz-text-decoration-color: blue;
}
*/

div.cke_float {
    div.cke_top {
        padding: 4px !important;

        span.cke_toolgroup {
            margin: 0 !important;
        }
    }
}

.bloom-textOverPicture .bloom-editable {
    padding-top: 1px; // for some reason this is needed to keep edit/non-edit text spacing the same
}

div.long-press-popup {
    z-index: 15005;
}

// in front of hint bubbles

.bloom-videoOverlay {
    position: absolute;
    height: 100%;
    width: 100%;
    box-sizing: border-box;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 1; // the whole point is to hide the video underneath
    border: 4px dashed @bloom-blue;
    background: aliceblue;
    color: @bloom-blue;
    font-size: 40px;
    z-index: @baseZIndexForContainers + 50; // stay above videoContainer
}

// This seems to produce about the amount of yellowing and blurring and darkness
// seen in http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=0F77B0242324523646B4C8F5A0BDDA52?doi=10.1.1.656.6430&rep=rep1&type=pdf,
// particularly Figure 1, "Visual acuity chart showing the blurring and color effects of a disabling brunescent cataract with a visual acuity of 20/200"
body.simulateCataracts {
    .bloom-imageContainer {
        background-color: yellow;

        img,
        canvas {
            filter: blur(3px) brightness(50%);
            mix-blend-mode: multiply;
            font-size: 20px;
            background-color: white;
        }
    }
}

// Hide images when we are putting a color-blindness overlay on top.
// This makes sure we don't get any trace if the size isn't perfect.
// More critically, when simulating BOTH color-blindness AND cataracts,
// the Canvas gets merged with what is behind it. We want that to be just
// the yellow background, not the image.
body.simulateColorBlindness {
    .bloom-imageContainer {
        img {
            visibility: hidden;
        }
    }
}

// I decided to take these out. The cog wheel is not very conspicuous and
// we already have code to make sure there's only one. The second rule
// is intented to make the cog visible (overriding the first one) when focus is in
// its translation group. It developed a problem when the cog moved outside the
// bloom-editable. Clicking the cog apparently causes the TG to lose focus,
// possibly because we're now clicking on something that is outside the
// (contenteditable) bloom-editable. Then the cog disappears without
// performing its click action.
// Hide the gear button unless the text box is focused for editing.
// #formatButton {
//     display: none;
// }

// using :focus-within works better than .cke-focus (See BL-11803.)
// .bloom-translationGroup:focus-within {
//     #formatButton {
//         display: inherit;
//     }
// }

// Moved from editOriginalMode.css when it became obsolete
//(no longer have original/translation=unlocked/locked modes)

ol#topics {
    list-style: none;
}

// There was a rule for bloom-readOnlyInAuthorMode, but this is obsolete
// There was also a file editTranslationMode, with a rule for bloom-readOnlyInTranslationMode,
// but the mode is obsolete so the rule has to be, even though we do still have one field so marked.

div.bloom-metaData {
    cursor: pointer;
    /*this signals to jscript that when the user clicks on this div, it should raise the message in data-message (which bloom will catch)*/
}

div.bloom-metaData textarea {
    /*border: transparent; /* jscript will translate to read only*/
    cursor: pointer;
    /*this signals to jscript that when the user clicks on this div, it should raise the message in data-message (which bloom will catch)*/
}

.enablePageCustomization div.marginBox {
    border: thin dotted rgba(133, 133, 193, 0.9) !important;
}

// end of block moved from editOriginalMode

// normally, the height is just a bit more than the paper size. We changed this in Bloom 5.5 so that we
// could make dialogs draggable but be constrained the the bounds of the body, without that meaning that
// you could only have the dialog in the top part of the screen that also had the page.
html,
body {
    height: 100%;
}

// Due to a Chromium bug, elements with our default relative position
// and a background color cause the caret not to show up. Somehow, this
// triggers when a decodable reader error span is nested inside one of these
// spans, even though when DR is active the rules that give these segments
// background color are not active. Nothing depends on thei being position:relative,
// so it's easiest to just prevent it. See BL-11633 for reproduction steps in Bloom 5.5.
.bloom-highlightSegment {
    position: unset;
}

// Don't show text over picture borders, resizing handles, or format buttons unless hovering over the image
// (This and several following rules were moved from content/bookLayout/bubble.less)
.bloom-imageContainer:not(.hoverUp) .bloom-textOverPicture {
    .bloom-editable {
        border: none;

        &:after {
            display: none !important;
        }
    }

    .ui-resizable-handle {
        display: none !important;
    }

    .bloom-dragHandle {
        display: none;
    }

    #formatButton {
        display: none;
    }

    .bloom-imageContainer {
        &:after {
            border: none; // overwrite rule from editMode.less
        }
    }
}

// This can color the svg into whatever color we want. Currently bloom-purple.
// While working on this PR I changed the color 4 times and it's a pain to keep
// exporting new svgs.
// Eventually if the color settles down, we can replace this with just svg's colored like we want.
// To generate new filter rules like this, use https://codepen.io/sosuke/pen/Pjoqqp
@ComicAffordanceFilter: invert(48%) sepia(14%) saturate(1147%)
    hue-rotate(257deg) brightness(90%) contrast(84%);

.bloom-imageContainer {
    .bloom-textOverPicture {
        .bloom-translationGroup {
            #formatButton {
                &:hover {
                    background-color: white; // make it stand out more from the image behind
                }

                img {
                    // turns the cog purple to match other Comic affordances, without requiring
                    // a different SVG. (Don't do this to the whole button, it messes with
                    // the background too when it's not transparent, e.g., when hovered.)
                    filter: @ComicAffordanceFilter;
                }
            }
        }

        .bloom-dragHandle {
            filter: @ComicAffordanceFilter;
            position: absolute;
            left: unset;
            // NB: right is set by a rule at the end of this file
            width: 22px;
            height: 22px;
            top: -15px;
            // This z-index should be above the canvas
            z-index: @dragHandleEventZIndex;
        }
    }
}

.bloom-textOverPicture {
    #formatButton {
        display: none; // Enhance: maybe don't create at all?
    }
}

// different bubble shapes require different positioning of the affordances
[data-bubble] {
    // These happen to be multiples of 1.4 is because they are 1% increments of 140px (the default text box width)
    .bloom-dragHandle {
        right: calc(100% + 1.4px);
    }

    [data-languageTipContent]:after {
        content: "" !important; // suppress these, now in overlay context controls
    }
}

[data-bubble*="caption"] {
    [data-languageTipContent]:after {
        right: calc(100% + 2.8px) !important;
    }
}

// hideAllCKEditors is toggled by bloomEditing.ts to prevent bl-12448
body.hideAllCKEditors .cke_chrome {
    // "display" is manipulated on the `style` element by ckeditor, so we can't use that
    visibility: hidden;
}

// We have all kinds of code that knows placeHolder.png is special. So it's nontrivial to
// switch and use a different placeholder image for GIFs. However, some of that code we
// already have prevents showing the placeholder except while editing. So we can get the
// effect we want (a different placeholder for GIFs) by just making the placeholder src
// and changing the content of the image.
.bloom-gif img[src="placeHolder.png"] {
    content: url("/bloom/images/Gif.svg");
    opacity: 0.4;
}

.invisibles {
    font-family: "SymChar";
    color: @bloom-purple;
}

// --------------------------------------------------------
// hide tips when the user clicks out of the page
.qtip {
    opacity: 0 !important;
    // When the page isn't focused, the tips will go away when you move off the page.
    // This keeps them around long enough to reach with the mouse.
    // We're using opacity instead of visibility because visibility doesn't animate.
    // A side benefit is that no longer how long it takes you to point at the bubble,
    // it will still light up if you point at it.
    transition: opacity 1s cubic-bezier(0, 0.7, 0.3, 1);
}
// but keep them visible when the user is interacting with them (BL-13224)
.qtip:hover,
.qtip:focus {
    opacity: 1 !important;
    transition: opacity 200ms ease-out;
}

// ----- Bloom Games ----
// Tweak the position of the Start/Correct/Wrong/Play control
#drag-activity-tab-control {
    position: relative;
    top: -8px;
}

// we want :blank, but it's not in browsers yet. So we simulate it by a mutation observer
// that adds a class to the editable when it is empty.
// In theory, the first rule handles an English editable that is followed by a blank bloom-content1,
// while the second handles the case where the blank is before the English.
// I have not been able to test the former because Bloom seems to reorder the bloom-content1 first.
// Enhance: possibly we could add a class that would let us identify the language that is the current
// default for the source bubble, rather than fixing on English. But the main thing is to see that
// there is a block there that should get some attention. The source bubble provides all the options.
.drag-activity-start
    .bloom-show-en-when-blank
    .bloom-editable[lang="en"]:has(~ .bloom-content1.bloom-blank),
.drag-activity-start
    .bloom-show-en-when-blank
    .bloom-content1.bloom-blank
    ~ .bloom-editable[lang="en"] {
    display: block; // overcomes rule that usually hides it (since it's not content1)
    position: absolute; // put it over the space where the bloom-content1 usually is
    top: 0;
    left: 0;
    pointer-events: none; // We can click right through it to the bloom-content1
    opacity: 40%; // dim a bit to make it look like a prompt.
}

canvas.moving {
    cursor: move;
}

.bloom-textOverPicture:not(.bloom-focusedTOP) * {
    cursor: default;
}
.bloom-textOverPicture.moving:not(.bloom-focusedTOP) * {
    cursor: move;
}

@resizeHandleRadius: 8px;
@sideHandleRadius: 4px;
@sideHandleCenter: 6px;
// We place this frame over each overlay to support resizing and cropping.
// The frame itself is invisible (and ignores pointer events), but it provides a container
// for the resize and crop handles and the toolbox below.
#overlay-control-frame {
    position: absolute;
    z-index: @dragHandleEventZIndex + 1;
    outline: 1px solid @bloom-blue;
    box-sizing: border-box;
    pointer-events: none;

    // The handles and toolbox are hidden when the overlay is being moved, resized or cropped
    // (except for the resize or crop control we are operating).
    &.moving {
        .bloom-ui-overlay-resize-handle,
        .bloom-ui-overlay-side-handle {
            display: none;
            &.active-control {
                display: block;
            }
        }
        &.bloom-ui-overlay-show-move-crop-handle {
            .bloom-ui-overlay-move-crop-handle {
                display: none;
            }
        }
    }
    // the "crop" handles on left and right are visible for text boxes
    // (though with a different function).
    &.has-text:not(.moving) {
        .bloom-ui-overlay-side-handle-e,
        .bloom-ui-overlay-side-handle-w {
            display: block;
        }
        // the south one is visible for text boxes only when auto-height is turned off.
        &.bloom-noAutoHeight .bloom-ui-overlay-side-handle-s {
            display: block;
        }
        // Enhance: Canva uses these handles on text boxes to resize the box by modifying
        // font size. This is nice for tweaking things but it's not clear how it should interact
        // with our style system. For now we're just not showing them for text boxes.
        .bloom-ui-overlay-resize-handle {
            display: none;
        }
    }

    // crop handles are, for now, only visible on images.
    .bloom-ui-overlay-side-handle {
        display: none; // default
        &.active-control {
            display: block;
        }
    }
    &.has-image:not(.moving) .bloom-ui-overlay-side-handle {
        display: block;
    }

    // The resize handles are the small circles in the four corners.
    // The move crop handle is the small circle in the center, used to change how an
    // image is cropped by (apparently) moving the image within the frame.
    .bloom-ui-overlay-resize-handle,
    .bloom-ui-overlay-move-crop-handle {
        position: absolute;
        width: @resizeHandleRadius * 2;
        height: @resizeHandleRadius * 2;
        border-radius: 50%;
        background-color: white;
        border: 1px solid @bloom-blue;
        box-sizing: border-box;
        pointer-events: all;
        //z-index: @canvasZIndex + 2;
        &.active-control,
        &:hover {
            background-color: @bloom-blue;
        }
    }
    .bloom-ui-overlay-resize-handle-nw {
        top: -@resizeHandleRadius;
        left: -@resizeHandleRadius;
        cursor: nw-resize;
    }
    .bloom-ui-overlay-resize-handle-ne {
        top: -@resizeHandleRadius;
        right: -@resizeHandleRadius;
        cursor: ne-resize;
    }
    .bloom-ui-overlay-resize-handle-sw {
        bottom: -@resizeHandleRadius;
        left: -@resizeHandleRadius;
        cursor: sw-resize;
    }
    .bloom-ui-overlay-resize-handle-se {
        bottom: -@resizeHandleRadius;
        right: -@resizeHandleRadius;
        cursor: se-resize;
    }

    .bloom-ui-overlay-move-crop-handle {
        top: calc(50% - @resizeHandleRadius);
        left: calc(50% - @resizeHandleRadius);
        display: none;
        //cursor: move;
    }

    &.bloom-ui-overlay-show-move-crop-handle
        .bloom-ui-overlay-move-crop-handle {
        display: block;
    }

    // Used to crop images, but for text boxes the left and right ones are actually used to change width (and thus
    // aspect ratio).
    .bloom-ui-overlay-side-handle {
        position: absolute;
        width: @sideHandleRadius * 2;
        height: @sideHandleRadius * 2;
        border-radius: @sideHandleRadius;
        background-color: white;
        border: 1px solid @bloom-blue;
        box-sizing: border-box;
        pointer-events: all;
        &.active-control,
        &:hover {
            background-color: @bloom-blue;
        }
    }

    .bloom-ui-overlay-side-handle-n {
        top: -@sideHandleRadius;
        left: calc(50% - @sideHandleRadius - @sideHandleCenter);
        width: @sideHandleCenter * 2 + @sideHandleRadius * 2;
        cursor: ns-resize;
    }
    .bloom-ui-overlay-side-handle-e {
        top: calc(50% - @sideHandleRadius - @sideHandleCenter);
        right: -@sideHandleRadius;
        height: @sideHandleCenter * 2 + @sideHandleRadius * 2;
        cursor: ew-resize;
    }
    .bloom-ui-overlay-side-handle-s {
        bottom: -@sideHandleRadius;
        left: calc(50% - @sideHandleRadius - @sideHandleCenter);
        width: @sideHandleCenter * 2 + @sideHandleRadius * 2;
        cursor: ns-resize;
    }
    .bloom-ui-overlay-side-handle-w {
        top: calc(50% - @sideHandleRadius - @sideHandleCenter);
        left: -@sideHandleRadius;
        height: @sideHandleCenter * 2 + @sideHandleRadius * 2;
        cursor: ew-resize;
    }
}

#overlay-context-controls {
    position: absolute;
    transform-origin: top left;
    &.moving {
        display: none;
    }
    pointer-events: none; // overridden for children, but the outer bit that's just for positioning should not be clickable
}
